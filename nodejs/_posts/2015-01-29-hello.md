---

title: 2.4 Hello
lastupdated: August 13, 2016

---


Most applications in node start by creating a web server and that is typically achieved using the following code

{% highlight javascript %}
var http = require('http');
var server = http.createServer();
{% endhighlight %}

The first line of code gets a reference to the **http** object using the `require` function and passing the name of the library as an argument. The http object is one of the many built-in libraries that we can readily use for programming. If you've used C/C++,Java or C# before, think of require as the equivalent of import or include.

The second line creates the actual http server by invoking the `createServer` method of the http object. This call returns a _Server_ object which we can use later for reacting to certain events. When an http request is made against our server, we want to listen to that event so we can do something meaningful in reaction to the request. We can do that by creating an event listener.

{% highlight javascript %}
server.on('request', doSomething); 
{% endhighlight %}

Hopefully, this syntax is familiar to you already. You may have used something similar in client-side Javascript like the one below.

{% highlight javascript %}
<script>
var button = document.getElementById("btn");
button.addEventListener('click', function(){
  // do something in here
});
</script>
{% endhighlight %}

What we did in the example above is basically attach an event listener to the button element such that when it is clicked, the anonymous functions (passed as the second parameter to the addEventListener call) kicks in whenever a click event on the button is detected by the browser. 

Going back to our first node example, we will use our newly created server object to listen to a **request** event. Whenever somebody hits our application by making an http request to the server, a **request** event is raised. It is up to us if we want to do something when this happens, and of course we want to do something.

{% highlight javascript %}
server.on('request', doSomething); 
function doService(req, res) {
  // do something interesting
}
{% endhighlight %}

So, in this code, we registered our server object to listen to a request event. For each request that we encounter, we will call the function `doSomething`. You will notice that our function accepts the arguments _req_ and _res_ which stands for http request and http responses, respectively. Everytime a request is encountered, node passes these two objects for our function to handle.

We'll do something simple when our doService function is called. We'll just print out a hello message to the browser. To make something appear on client browser we need to (a) set the response status for the http request and (b) write the actual response, this could be plain text, html, json or something else.

Each http request that you make against any web server will elicit a response. When a browser makes a request to the server and the server has fulfilled the request without problems, the server sends the response code **200** back to the requester (usually a browser, but not always). If there were problems in fulfilling the request, the server sends a different response code e.g. **404** if the resource requested was not found on the server. So, setting response codes is kind of expected from web servers, it is part of the http specification after all.  

To set the response code, we write

{% highlight javascript %}
res.statusCode = 200;
{% endhighlight %}

If you cannot be bothered to set the response code explicitly, the default is 200. You might want to keep this in mind because not all http responses will be **OK**, sometimes you need to send a different response code, depending on how you write your app.

Next, we'll write the header.

{% highlight javascript %}
res.setHeader('Content-Type', 'text/html');
{% endhighlight %}

Alternatively, we can set the response code and write the headers at the same time

{% highlight javascript %}
res.writeHead(200, {'Content-Type':'text/html'});
{% endhighlight %}

Once the header and response codes have been written, we can now start writing the actual response. The `response` object is actually a stream, so in order to write something to the browser, we just need to write on this stream.

{% highlight javascript %}
res.write("<html><h1>Hello Node</h1></html>");
res.end();
{% endhighlight %}

That second line is very important. Calling the `end` method signals that we are finished writing and that we want to flush the stream. If you forget that, the browser won't receive anything in response.

The next piece of code we need to write is the one that opens up a socket and allows our server to listen and accept client requests. 

{% highlight javascript %}
server.listen(1025, function(){
  console.log("Waiting for connections...");
});
{% endhighlight %}

The first parameter to the `listen` method is the port number, you can choose any number from 0 up to 65535, but it's generally a good idea to stay away from port numbers 1024 and lower for two reasons (1) ports 1024 and below are privileged or system ports in UNIX or Linux. Meaning, you've got to be root in order to run a service on those ports (2) a lot of the well known ports like http, ftp, smtp, ssh etc. If you want to know more about how ports and service names are assigned, you can read [RFC6335](https://tools.ietf.org/html/rfc6335). For a list of the well known ports you can visit the [IANA page](http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).

The second parameter to `listen` is just a function that will be called when the socket is opened. Were just printed a simple message to the screen. At this point, the application will listen and respond to incoming http connections. It won't stop until you kill the server process, CTRL-C usually does the trick.

# All Together Now

So, we know how to use a built-in library, listen for the request event, set http response cods, write http headers, write something in the client's browser and open a server socket. Let's put all the codes together.

{% highlight javascript %}
var http = require('http');
var server = http.createServer();

server.on('request', doService);

function doService(req, res) {
  res.writeHead(200, {'Content-Type':'text/html'});
  res.write("<html><h1>Hello Node</h1></html>");
  res.end();
}

server.listen(1025, function(){
  console.log("Listening on port 1025");
});
{% endhighlight %}
 
Alright, the code works but it doesn't look and quite feel like idiomatic Node, so let's fix that. We'll refactor the code a bit.

{% highlight javascript %}
var server = http.createServer();
server.on('request', doService);
{% endhighlight %}

The two lines of code above where we create the server and listen to incoming request can actually be written as

{% highlight javascript %}
var server = http.createServer(doService);
{% endhighlight %}

We can skip the event registration code and simply pass a function to the `createServer` function, it will have the same effect. We can further refactor the code by passing an anonymous function, instead of a named function to the createServer method.

{% highlight javascript %}
var server = http.createServer(function(req, res){
  // write the header and other stuff here
});
{% endhighlight %}

Now it looks like idiomatic node code. Let's put all together, again.

{% highlight javascript %}
var http = require('http');

var server = http.createServer(function(req, res){
  res.writeHead(200, {'Content-Type':'text/html'});
  res.write("<html><h1>Hello Node</h1></html>");
  res.end();
});

server.listen(1025, function(){
  console.log("Hello app listening on port 1025");
});
{% endhighlight %}

# A Note on Node Development
 
If you've written web apps before in PHP, Java or .NET, what we just did in the previous section might seem a bit primitive and quite off putting. In other web platforms, we didn't have to create a web server, we would just create the html document or something that would transpile to html and leave the servicing of the documents to the web server. But don't walk away just yet, programming in node is a low level enterprise but that is not a weakness, that is a strength. That hello world sample code above is just a bad sample, you're not supposed to develop web applications like that. We'll explore some more use cases and features of node in the up coming sections.









