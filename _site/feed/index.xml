<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Ted's blog'</title>
 <link href="http://tedhagos.com/feed/" rel="self"/>
 <link href="http://tedhagos.com/"/>
 <updated>2013-10-23T22:02:10+08:00</updated>
 <id>http://tedhagos.com/</id>
 <author>
   <name>Ted Hagos</name>
   <email>ted@thelogbox.com</email>
 </author>

 
 <entry>
   <title>Two Factor Authentication</title>
   <link href="http://tedhagos.com /two-factor-auth-using-sms"/>
   <updated>2013-07-04T00:00:00+08:00</updated>
   <id>http://tedhagos.com /two-factor-auth-using-sms</id>
   <content type="html">&lt;p&gt;One way to achieve a two factor authentication is to couple a simple website login with an SMS  One Time PIN. The username/password (what the user know) is the first layer of security challenge. The web application generates a random number which is valid only for current browser session, sends the generated random number via a third party SMS gateway and asks the user to input the OTP (One Time Pin) in order to satisfy the security challenge.  The OTP will serve as the “what you have” part for our 2 factor authentication.&lt;/p&gt;

&lt;p&gt;This is a poor man's approach to Two Factor authentication. If you are strapped for cash and cannot afford the fancy gadgets that has random number generators (the one that changes every five minutes), then this solution might be good enough in the meantime.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2factor-auth-sms.png&quot; /&gt;&lt;/p&gt;

&lt;div id=&quot;cap&quot;&gt;
  Fig 1: Sequence/Workflow of Two Factor Auth
&lt;/div&gt;


&lt;p&gt;It is best (and recommended) to seek third party integration to handle the SMS messaging aspect. A fully functioning SMS gateway is non-trivial to build and develop from scratch. There are lots of SMS gateway providers {TODO: Compile some options for third party SMS gateway providers}&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;THINGS TO CONSIDER&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Session Management&lt;/strong&gt; will not be very simple. You will need to account the coupling of a randomly generated number (a one time pin, like what most banking sites use). Associate it with the current browser session. The basic idea is to expire that PIN after the browser session has ended. You will need to carefully think about simpistic state management now.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Messaging component&lt;/strong&gt; will have to be written. Surely you won't write the SMS-specific codes intermingled with your primary business logic? would you? Depending on what SMS gateway solution you will choose, this messaging component maybe as simple as making a RESTful call or integrating a complicated client-side library. You must consider complexity of integration when choosing a third party solution for th SMS gateway.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cost&lt;/strong&gt; of sending or receiving 1 SMS message. Some services are free, most are not. You need to do some cost analysis here.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;HOME GROWN SMS SOLUTION&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you are quite handy on Linux, you can build an SMS gateway of your own. You can try to use &lt;a href=&quot;http://kannel.org&quot;&gt;kannel&lt;/a&gt; or concoct your own using &lt;a href=&quot;http://thelogbox.com/send-receive-sms-messages-usb-modem-linux/&quot;&gt;gnokii, smsd and a USB modem&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For the hardcore, if you can still remember your RS-232 programming and you can lay your hands on an old copy of the Hayes AT&amp;amp;T GSM modem commands, you can go down that route too.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;ANOTHER SOLUTION FOR 2 FACTOR AUTH&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Use the MAC address of the device. That will satisfy the “what you have” requirement. The device itself is the security token. This is simpler and more transparent to the user because of the reduced steps on the workflow.&lt;/p&gt;

&lt;p&gt;This cannot be easily or eleagantly done if the user is on a Desktop machine and accessing the application via a browser. There is no way (yet) to get the MAC address of the machine without resorting to trickeries like ActiveX. The MAC information is not on the TCP packet, it is on the Ether. The Ether information does not make it to the HTTP headers (which is what you have on the server side of the web app)&lt;/p&gt;

&lt;p&gt;And so, the MAC solution might be a better fit for mobile devices. I would suspect that a standard API exists for extracting MAC on IOS or Android.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>On Java 8</title>
   <link href="http://tedhagos.com /java8-notes"/>
   <updated>2013-07-02T00:00:00+08:00</updated>
   <id>http://tedhagos.com /java8-notes</id>
   <content type="html">&lt;p&gt;You can get Java 8 by way of &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/ea-jsp-142245.html&quot;&gt;Oracle Early Access&lt;/a&gt;. This is a mainstream, run of the mill installer though. That means you install this on a machine, it takes over the Java environment for that machine. Don't do that! Not to your workhorse and go-to machine. Do it a VM, it is safer and prudent that way.&lt;/p&gt;

&lt;p&gt;On a Debian VM or Debian-ish machines, it can be pulled from the repos&lt;/p&gt;

&lt;pre&gt;

sudo add-apt-repository ppa:webupd8team/java
sudo apt-get update
sudo apt-get install oracle-java8-installer

&lt;/pre&gt;


&lt;p&gt;The Windows installation should be easy to figure out, there is no need to write it here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If you cannot go the VM route&lt;/strong&gt; you can still try out Java 8. There is a downloadable version of Java 8 Development Kit at &lt;a href=&quot;http://java8.jdk.net/download.html&quot;&gt;java8.jdk.net/download&lt;/a&gt;that does not require installation. You may need to figure out how to use side-by-side with your other installation of the JDK though. For my Mac setup, this is what I did&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Download the installer from &lt;a href=&quot;http://java8.jdk.net/download.html&quot;&gt;java8.jdk.net/download&lt;/a&gt; or &lt;a href=&quot;http://java8.jdk.net/download.html&quot;&gt;java8.jdk.net/lambda&lt;/a&gt;, the second one is larger and has lambda support&lt;/li&gt;
&lt;li&gt;Extract the contents and tuck it away somewhere&lt;/li&gt;
&lt;li&gt;Create softlinks to the java8 executables, might be a good idea not to override your usual &lt;strong&gt;java&lt;/strong&gt; and &lt;strong&gt;javac&lt;/strong&gt;. I named mine &lt;strong&gt;java8&lt;/strong&gt; and &lt;strong&gt;javac8&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;pre&gt;

sudo ln -s /somewhere/jdk8/bin/java /usr/bin/java8
sudo ln -s /somewhere/jdk8/bin/javac /usr/bin/javac8

&lt;/pre&gt;


&lt;p&gt;I hope some people in the community will already invest sometime on something like rvm for Java, so I won't have to do this with Java 9&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Presentation & Slides with Beamer class</title>
   <link href="http://tedhagos.com /latex-slides"/>
   <updated>2013-02-13T00:00:00+08:00</updated>
   <id>http://tedhagos.com /latex-slides</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;1. BASIC STRUCTURE OF A PRESENTATION FILE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The whole presentation is inside &lt;code class=&quot;codeblock&quot;&gt;\begin{document} .. \end{document}&lt;/code&gt; .Each slide is enclosed in &lt;code class=&quot;codeblock&quot;&gt;\begin{frame} \end{frame}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Sample document is shown below&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
%
% sampledoc.latex
%
\documentclass{beamer}
\begin{document}

\begin{frame}
\frametitle{First}
\framesubtitle{the subtitle}
% content
\end{frame}
 
\begin{frame}
\frametitle{Second}
\framesubtitle{another subtitle}
% content
\end{frame}

\end{document}
&lt;/pre&gt;


&lt;p&gt;Compile the latex source. &lt;code class=&quot;codeblock&quot;&gt;xelatex &amp;lt;filename.tex&gt;&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;2. TITLE PAGES&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
\documentclass{beamer}
 \title[Title of Presentation]{Presentation title}
 \author{Ted Hagos}
 \institute[theLogBox]{theLogBox.com \\
 \medskip {\emph{ted@thelogbox.com}}}
\date{\today}
\begin{document}

\begin{frame}
\titlepage
\end{frame}
\begin{frame}
\frametitle{First}
\framesubtitle{the subtitle}
% content
\end{frame}
 
\begin{frame}
\frametitle{Second}
\framesubtitle{another subtitle}
% content
\end{frame}

\end{document}
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;Build the title information before &lt;code class=&quot;codeblock&quot;&gt;\begin{document}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Make the first frame as the title page by calling &lt;code class=&quot;codeblock&quot;&gt;\titlepage&lt;/code&gt; on the first frame&lt;/li&gt;
&lt;/ol&gt;


&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;3. INSERTING SOURCE CODES INTO SLIDES&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
\documentclass{beamer}
\setbeamercovered{transparent}
\usepackage{pxfonts}
\usepackage{listings}
\begin{document}
 
\lstset{language=java,
        numbers=left,
        numberstyle=\tiny,
        showstringspaces=false,
        frame=leftline,
        tabs=2,
        keywordstyle=\color{red}
        }
 
\begin{frame}[fragile]
\frametitle{\texttt{Hello.java}}
\begin{semiverbatim}
  
\begin{lstlisting}
class Hello {
  public static void main(String args[]) {
  
  }
}
\end{lstlisting}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Second frame}
\begin{semiverbatim}
  
\begin{lstlisting}
class Hello {
  public static void main(String args[]) {
    System.out.println(&quot;Hello Java&quot;);
  }
}
\end{lstlisting}
\end{semiverbatim}
\end{frame}

\end{document}
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;Use the &lt;em&gt;listings&lt;/em&gt; package&lt;/li&gt;
&lt;li&gt;Use the [fragile] option when defining the frame&lt;/li&gt;
&lt;li&gt;Enclose the source code inside &lt;em&gt;listings&lt;/em&gt; environment nested inside a &lt;em&gt;semiverbatim&lt;/em&gt; environment&lt;/li&gt;
&lt;/ol&gt;


&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;4. HOW TO SKIP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Use &lt;code class=&quot;codeblock&quot;&gt;\bigskip&lt;/code&gt; to produce vertical whitespace. You can also use &lt;code class=&quot;codeblock&quot;&gt;\medskip&lt;/code&gt;, it's like &lt;code class=&quot;codeblock&quot;&gt;\bigskip&lt;/code&gt;, only, well, less&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;5. INCLUDING BIBLIOGRAPHIES AND REFERENCES&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
\documentclass{beamer}
\setbeamercovered{transparent}
\usepackage{pxfonts}
\usepackage{listings}
\begin{document}
\lstset{language=java,
        numbers=left,
        numberstyle=\tiny,
        showstringspaces=false,
        frame=leftline,
        tabs=8,
        keywordstyle=\color{red}
        }
 
\begin{frame}[fragile]
\frametitle{\texttt{Hello.java}}
\begin{semiverbatim}
  
\begin{lstlisting}
class Hello {
  public static void main(String args[]) {
  
  }
}
\end{lstlisting}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{A basic Java program}
\framesubtitle{class and method structure}
\bigskip

The following code is the simplest java program you can 
code and run. In the tradition of Hello World program of Kernighan 
and Ritchie, here is the Hello World in Java. 

\begin{semiverbatim}
  
\begin{lstlisting}
class Hello {
  public static void main(String args[]) {
    System.out.println(&quot;Hello Java&quot;);
  }
}
\end{lstlisting}
\end{semiverbatim}
\begin{enumerate}
  \item start with a class
  \item define methods inside a class

\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Citations}
\bigskip
If you need to cite somebody, like this \cite {cite1} or quote somebody, use 
the \\cite command, you need to define a bibliography somewhere. Also, you 
will need to compile twice (use xelatex 2x) to produce the bibtex entries  
\end{frame}

\begin{frame}
\frametitle{References}
\footnotesize{
\begin{thebibliography}{99}
 \bibitem[The Java Programming Language, 1995]{cite1} James Gosling (1995)
 \newblock The Oak Programming Language.
 \newblock \emph{Sun Micro Papers} 
\end{thebibliography}
}
\end{frame}

\end{document}
&lt;/pre&gt;


&lt;ol&gt;
&lt;li&gt;The bibliography is usually the last frame&lt;/li&gt;
&lt;li&gt;Remember to run &lt;code class=&quot;codeblock&quot;&gt;xelatex&lt;/code&gt; twice when you use &lt;strong&gt;bibitems&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;HOW TO USE PANDOC WITH THE BEAMER CLASS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can create beamer slides also using &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;&lt;strong&gt;Markdown&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://johnmacfarlane.net/pandoc/&quot;&gt;&lt;strong&gt;Pandoc&lt;/strong&gt;&lt;/a&gt;. Say that the following text is written on the file &lt;em&gt;sample-markdown.md&lt;/em&gt;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
% A simple, no-nonsense presentation
% Ted Hagos
% February 13, 2013 

# Part 1

## Title of frame 1
- One is
- followed by 2

## and frame 2
- then three
- after three is four

# In the evening

## this is frame 3
- five, and
- finally six

# Part 2

## frame 4
  - you know
  - the drill

## frame 5
&lt;/pre&gt;


&lt;p&gt;Compile the the markdown file &lt;code class=&quot;codeblock&quot;&gt;pandoc -t beamer sample-markdown.md -o sample-markdown.pdf &lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;REFERENCES&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://johnmacfarlane.net/pandoc/demo/example9/producing-slide-shows-with-pandoc.html&quot;&gt;John Mcfarlane&lt;/a&gt; - Using pandoc with the beamer class&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.tex.ac.uk/tex-archive/macros/latex/contrib/beamer/doc/beameruserguide.pdf&quot;&gt;The beamer class&lt;/a&gt; - PDF resources&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Working on API Projects</title>
   <link href="http://tedhagos.com /api-projects"/>
   <updated>2013-01-31T00:00:00+08:00</updated>
   <id>http://tedhagos.com /api-projects</id>
   <content type="html">&lt;p&gt;You will underestimate the efforts on your first API project. Even if you have done many an estimations before and you have participated in many a projects, if none of them were API development, you will be painfully reminded that &lt;strong&gt;there is always a first time for everything&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;API projects are not exactly the same as a web app, or mobile app or a desktop app. They should not be estimated as such. You will spend more effort on development and unit testing on API projects.&lt;/p&gt;

&lt;p&gt;Once you have built the API, you will spend time testing it. The way to test it is to build an application that will use the API. &amp;mdash; shouldn't you actually build a unit test also for that app that will use your API? If you won't, how will you get an insight on how the APIs will be used by others. You need to get into the heads of your users if the API is to be robust.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Deadline, Scope, Resource</title>
   <link href="http://tedhagos.com /fixed-deadlines-moving-scope"/>
   <updated>2013-01-30T00:00:00+08:00</updated>
   <id>http://tedhagos.com /fixed-deadlines-moving-scope</id>
   <content type="html">&lt;p&gt;A hard deadline is common place in software development projects. There is a fixed date when to ship the software out of the door, but the scope of the project and the resources working on them are not necessarily fixed.&lt;/p&gt;

&lt;p&gt;In a perfect world, before a single line of code is ever written, everybody involved in software development (including the client) has a good understanding of what needs to be done, how to get there, how much sweat will it take and for how long everybody sweats. In a perfect world. But it isn't perfect. There are a lot of people involved. A lot of them have stakes. Not everybody is aware of what is going on. Not everybody is on time.&lt;/p&gt;

&lt;p&gt;While Agile methods have taught a lot of people not to do things serially and and not to put things in the critical path, the software development part is not the be-all and end-all of projects. There are other people involved in the value chain of projects, and &lt;span style='text-decoration:line-through'&gt;some&lt;/span&gt; a lot are way up on this chain. These are people waiting to pay for the software (more often than not, they have already paid for the software), people who promised some other people a delivery date for the software, people who manage some people who promise some other people a delivery date for the software, so on and so forth. Like it or not, they can exert a lot of influence on when that software should be out of your door.&lt;/p&gt;

&lt;p&gt;If you have been doing this long enough, you have an overdeveloped thick skin for the silliness of the SDLC (Software Development Life Cycle). If you are new at this, prepare for temper swings, yours and that of others. But keep your cool. Yelling matches and snide emails are not useful &amp;mdash; restraint is.&lt;/p&gt;

&lt;p&gt;There are 3 things you need to be acutely aware of in a project. First, how much work is there (features), how many people do you have to work on them (resource) and how much time do you have (deadline). Those are the basics. If one of these three things move, you need to start taking notes of how it will impact the other two. There is always impact.&lt;/p&gt;

&lt;p&gt;If the scope of the project keeps moving, either the deadline or the resources will stretch. Stretching the resources can mean either extending their hours (beyond 8) or adding warm bodies to the project. Neither has desirable effects. When you stretch people's working hours, their focus is thinly spread, the brain needs a healthy dose of sleep. People who are tired makes more mistakes. You might be able to ship that software after all, but it might not behave like you expect it to. Adding warm bodies is  a pipe dream also, at least on short projects &amp;mdash; the ones you measure in months, not in multi-years. You are throwing new comers to the deep-end, they will need to familiarise and absorb what your other guys have been working on in the past couple of months. They will ask questions and clarify things. You will spend time with them. It will be time you don't have. Familiarise your self with the law of diminishing returns.&lt;/p&gt;

&lt;p&gt;The only thing left to manage is the deadline. And the deadline is very sensitive area to a lot of people. This is the one that causes tempers to flare. When tempers flare, just check your own, there is nothing you can do with other's temper and demeanour. A discussion on moving the deadline will always be a difficult one. Accept it. Prepare for it. Discuss it calmly and intelligently. Don't get sucked into the blame-storming frenzy that ensues. Focus on problem solving.&lt;/p&gt;

&lt;p&gt;The tricky part about running out of time is that it's not always easy to tell when you are. Projects are never late one week or one month. Projects are late one day at a time, it won't seem so bad on the first day you find out you are behind. It might not seem so bad even during the second day &amp;mdash; and there is the rub. How do you tell when it's bad enough? How can you be certain that 4 more hours of delay will negatively impact your team's ability to deliver the software, as agreed and as expected? Where is the point when recovery and salvage are no longer possibilities? Sadly, it's an acquired skill, every project is different. Some or all of the people in your team might be different, a different client, slightly different set of features, different version of libraries you are using  etc. You just need to do it long enough and plenty enough to get better at it.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MISC</title>
   <link href="http://tedhagos.com /misc"/>
   <updated>2013-01-01T00:00:00+08:00</updated>
   <id>http://tedhagos.com /misc</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;Old Airport Express in OSX Mountain Lion&lt;/strong&gt;. How to salvage an old airport express for use in OSX 10.8 &lt;a href=&quot;https://docs.google.com/document/d/1nFsp9X1TTm8eww6jeO9N8lNgULTGrMrKxtUIa7wHPqE/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google Apps Email Solution for Small Groups&lt;/strong&gt;. Some verbiage if you need to convince some people (your bosses) why adopt the Google Business Apps for email. &lt;a href=&quot;https://docs.google.com/document/d/1x8rOCEWaa-h9oxRb1gJJswUw0TvsJ9TwZB6SEzqb8ls/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkSys WiFi Routers and AP&lt;/strong&gt;. Configurations for old linksys wifi routers and access point. These the WRT series. &lt;a href=&quot;https://docs.google.com/document/d/1dNz-ggMjbcSYTjlzehzxN-CO1rSqO-rwbxUaOnm-TKE/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DLink 605L&lt;/strong&gt;. Configuration for DLink WiFi router. &lt;a href=&quot;https://docs.google.com/document/d/1F7nLxoQGhY7UN_aS98X8lKVT2pfgthE6yQWy7pEt29Q/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Email Campaigns and Junk Boxes&lt;/strong&gt;. Steps, Tips, Traps and Tricks. How to avoid the junk box when sending an email campaign. &lt;a href=&quot;https://docs.google.com/document/d/1pw_2iU3ZAOjepw-S_NU3xUpkdEh9bf4DJhk5tEsZEF4/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Switching to a Jekyll Blog&lt;/strong&gt;. Steps for building a Jekyll Blog. &lt;a href=&quot;https://docs.google.com/document/d/1ZsnGk4nwnK7Za__iwt7Z0QKcfqgWAqSsbj1nyPicjLQ/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Migrating to a new iPad&lt;/strong&gt;. Steps on how to move to a new iPad. &lt;a href=&quot;https://docs.google.com/document/d/1wJhWo0DcQCYCW-HQnk9oQjINBngLFC3Adh2ZADd2mdc/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Synchronizing Email Data on iOS and MacBook&lt;/strong&gt;. Steps on how to always sync email data on iOS, MacBook and Other Devices without using iCloud. &lt;a href=&quot;https://docs.google.com/document/d/1NgWrdU-3u6E1YbrMCxN1K8ZB4DyZtn7zDKXZejXyeCI/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PostgreSQL on OSX&lt;/strong&gt;. Easiest way to run PostgreSQL on OSX is to download an app from PostgresApp. Follow these steps &lt;a href=&quot;https://docs.google.com/document/d/1gsLSqgB6EV016hxFNLr4oRwvMFODmcqQl1X7sHYNrZU/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crafting Learning Objectives&lt;/strong&gt;. Use Blooms Taxonomy for learning objectives. &lt;a href=&quot;https://docs.google.com/document/d/17DhpUO00UMZIotX1gHLjBNohgxECbEhBd5HKeqUqFZ4/edit?usp=sharing&quot;&gt;Google Drocs MISC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Licensing Source Code&lt;/strong&gt;. &lt;a href=&quot;https://docs.google.com/document/d/1w0NyKaOZCEWBHdZ0AlwWzcYuoUoh08eCxOrP8fTCW5E/edit?usp=sharing&quot;&gt;Google Docs MISC&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Long Fuse</title>
   <link href="http://tedhagos.com /long-fuse"/>
   <updated>2012-12-27T00:00:00+08:00</updated>
   <id>http://tedhagos.com /long-fuse</id>
   <content type="html">&lt;ol&gt;
&lt;li&gt;a device in a bomb that controls the timing of an explosion&lt;/li&gt;
&lt;li&gt;a book by Dr. Eric Haseltine (Long Fuse, Big Bang …)&lt;/li&gt;
&lt;li&gt;long term goals. not the same as task list items, but each item on the task list should keep the spark going. It's the big picture, the balls you don't drop. It's your marshmallow test. They will not be immediately satisfied. It's not the &lt;em&gt;here and now&lt;/em&gt;, so you need to be very patient and very cool about it&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>On the Subject of Focus</title>
   <link href="http://tedhagos.com /notes-on-focus"/>
   <updated>2012-12-23T00:00:00+08:00</updated>
   <id>http://tedhagos.com /notes-on-focus</id>
   <content type="html">&lt;h2&gt;The Brain's Playbook&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Tuesday , January 08 , 2013&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I know what I have to do, I've written (and rewritten) them down in the notebook, in the goal papers; yet I don't want to do them. There's a tug-of-war happening inside and the lazy guys seems to be winning.&lt;/p&gt;

&lt;p&gt;My primitive brain is taking over, it's telling me to do nothing, conserve energy (that means sleep) and eat (fast and plenty)—I know that if I take my eyes off the focus for the day, the lazy guy is gonna win. I have to shake this monkey off my back, I've got lots of things to do today—maybe a 15 minute cardio should perk me up again; or coffee, that can do the trick too; just don't put sugar in it because the lazy guy loves sugar.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;The First Two Hours&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Monday , January 07 , 2013&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Wake up 2 hours earlier than your usual. After the morning rituals, coffee etc, don't turn on the computer, don't check your email, don't check messages on your phone lest your mind will wander around, will fleet from thought to thought and get filled with &lt;em&gt;little things&lt;/em&gt; — remember what Stephen Covey said on &lt;em&gt;First things First&lt;/em&gt;, rocks first, then stones, then pebbles then sand. Look at the rocks first, attend to the rocks first. Stay disconnected for the first two hours. Use the time to;&lt;/p&gt;

&lt;p&gt;Look at your todo list for the week
Look at your todo list yesterday, if some items fell in the crack, add them to the list for the day. Can't steal time
Write (rewrite) the todo list for the day. See which ones in the list can be done in 2 hours, but can potentially contribute the most to results of the day (80/20). Be brutal about the selection. Those task that will not make the cut are probably less important anyway—either delay them, queue them, delete them altogether.
The first two hours is important, it sets the tone of the day. If you don't set the tone, the hours will pass by and you will wander aimlessly; sure you will respond to emails, answer your phone, engage in conversations—but those are probably the 80% of your activity that gives rise to only 20% of your results (maybe even a lot less than 20%)—do the important stuff first; the important ones for you, that is.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;It's (not) Just a Task List&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Friday , December 28 , 2012&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;As you move through your task list for the day, it doesn’t hurt to include what artefact will it produce. What do you expect to get out of it. Sometimes a task doesn’t have an artefact, and that’s fine—but more often than not, a task does have an artefact, even if it is just a single page containing your notes, and how you clarified your thoughts on it.&lt;/p&gt;

&lt;p&gt;It is important to ask what is the victory condition for the task, when do you stop working on it. If the victory condition is unclear, then maybe the task is bigger than what you originally thought it was—tactical or long term goal, perhaps.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;Low Grade Stress&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Wednesday , December 26 , 2012&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The sinking feeling you are getting is most likely because you have a lot of thoughts in your mind. Specifically thoughts that make you feel guilty that you haven’t done enough and you wasted way too much time watching movies, checking on your website and scanning through emails—holiday breaks can do that to you.&lt;/p&gt;

&lt;p&gt;After a movie marathon, couple of packs of cigarettes, lots of caffeine and serial eating, it’s a bit difficult to go back to a centered state of thought. You will fall out of rhythm. This happens from time to time, your mind is playing tricks because your short term memories are not about work, they are about decadence—and its a tricky business to catch yourself when you are accelerating towards decadence and lethargy. It usually takes a boss or another authority figure to kick you from behind or give you a whack on the back of your head so you can get buttoned up again.&lt;/p&gt;

&lt;p&gt;That sinking feeling is a stressor, it’s low intensity but it lingers. It’s a lot like the flickering light on your work area or the slow march of traffic you go through everyday. Adrenaline is not going to solve it. You cannot simply explode into action, beat it to a pulp or run away from it.&lt;/p&gt;

&lt;p&gt;Luckily, you already wrote down your list of long fuses — you have written them down, haven’t you? — and you keep a journal pretty regularly—you do keep a journal, don’t you?—A list of long fuses keeps your eyes on the far horizon and your journal records some minutiae of the tactical challenges you were trying to solve before you drifted into the path of aimless-ness. Get back on those, let your mind get on the groove of your task list. You can’t swallow an elephant, you got to slice it up in bite-sized pieces.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;Lazy bones, Lazy mind&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Monday December 24 , 2012&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What exactly is that one thing you are waiting to happen before you do the big things on your list. You’ve already done the Guy Kawasaki advise, M-A-T right? So what’s eating you up. Why are you dragging your feet.&lt;/p&gt;

&lt;p&gt;What conditions are you waiting for. A perfect sunny day wasn’t part of your assumptions, you were gonna do these things regardless — it’s just lethargy isn’t it? or you don’t think you deserve it. You think it’s not ”you”, not within your elements — or its’ too deep for you.&lt;/p&gt;

&lt;p&gt;You need to practice more writing. Articulate exactly what are the things that need to happen first, before the big things on your list start happening.&lt;/p&gt;

&lt;p&gt;Big things on your list mostly falls under the category of multi-step problem. You can’t skip the intervening solutions and jump right to the last problem — maybe that is what’s keeping you, because you think you can&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;To the front or to the side?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Monday December 24 , 2012&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For most problems, looking for that one right answer is a natural approach to take. Process of elimination is very ingrained and wired deep into our thinking — it’s not a bad way to solve problems. But when you are stomped, the logical approach maybe of limited use. Another way to proceed could be to think sideways, the process of generation. The goal is not to eliminate options, rather to generate them.&lt;/p&gt;

&lt;p&gt;The rub is to know when to move forward and when to move sideways. This is probably why the thinking process is an art form.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;Snowballing thoughts&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Sunday , December 23 , 2012&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Try to avoid mental snowballing. This one usually occurs when you are so absorbed into a negative detail. You will begin rehearsing one thought after another in your mind, you might even rehearse conversations that will eventually make you feel agitated.&lt;/p&gt;

&lt;p&gt;Thought rehearsal is good, if it’s a positive thought, if it’s a negative thought, it should be dealt with differently. Out of the 10 (bad) things you think will happen, 1 (or maybe none at all) will happen. Life is short, time is short—such a waste to spend it in paranoia&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;SLOWING DOWN HELPS&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Sunday , December 23 , 2012&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Don’t try to take on the challenges at once. Speed of response is not always a priority. Sticky problems always have lots of things underneath them — the ones that you don’t see; Remember Pareto? 8 parts of the problem is submerged and unseen. You need to uncover them first before you can solve the 2 parts of it which are visible and are in your face.&lt;/p&gt;

&lt;p&gt;This is why you need to always catch your self when you are in an agitated state. Going from thought to speech in 10 seconds is a dangerous thing. Absorb, relax, collect your thoughts, ask the 5 whys, then formulate a response&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>HTML5 Canvas</title>
   <link href="http://tedhagos.com /html5-canvas"/>
   <updated>2011-04-07T00:00:00+08:00</updated>
   <id>http://tedhagos.com /html5-canvas</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://thelogbox.com/html5-what-you-will-need/&quot;&gt;HTML5 Canvas Tutorial&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OSX Cheatsheet</title>
   <link href="http://tedhagos.com /osx-cheatsheet"/>
   <updated>2008-02-12T00:00:00+08:00</updated>
   <id>http://tedhagos.com /osx-cheatsheet</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;1. SHOW THE ROUTING TABLE&lt;/strong&gt;. &lt;code class=&quot;codeblock&quot;&gt;route print&lt;/code&gt; won't work, try &lt;code class=&quot;codeblock&quot;&gt;netstat -nr&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;2. HIDE OR SHOW HIDDEN FILES IN FINDER&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;If you are always working on the command line, don't even bother with this, a simple &lt;strong&gt;ls -a&lt;/strong&gt; should do the trick. If however, you really do need to display hidden stuff in Finder, here's how to do it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ defaults write com.apple.finder AppleShowAllFiles -bool YES &lt;br/&gt;
  $ defaults write com.apple.finder AppleShowAllFiles -bool NO
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The first one obviously shows hidden files and the other hides it. You need kill the Finder app each time you change this setting.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ killall Finder
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;3. HOW TO SET THE HOSTNAME&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ sudo scutil --set HostName anyname_you_want
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;4. JAVA&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The JDK nor the JRE is not included on Mountain Lion anymore, but it fairly easy to get. Open a Terminal.app session and type &lt;span class=&quot;codeblock&quot;&gt;java&lt;/span&gt;, it should launch a window asking you if you want to install Java.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JAVA 8&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Don't install the EA release from Oracle, not on your workhorse machine. If you just want to play around with JDK8, get it at &lt;a href=&quot;http://java8.jdk.net/download&quot;&gt;java8.jdk.net/download&lt;/a&gt; or &lt;a href=&quot;http://java8.jdk.net/lambda&quot;&gt;java8.jdk.net/lambda&lt;/a&gt;. Untar the downloaded files, then set softlinks to executables.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ sudo ln -s /somewhere/jdk8/bin/java /usr/bin/java8 &lt;br/&gt;
  $ sudo ln -s /somewhere/jdk8/bin/javac /usr/bin/javac8
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;5. CONTROL ANTI-ALIASING&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ defaults -currentHost write -globalDomain AppleFontSmoothing -int 1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;WHERE:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1: Light anti aliasing&lt;/li&gt;
&lt;li&gt;2: Medium&lt;/li&gt;
&lt;li&gt;3: Strong&lt;/li&gt;
&lt;/ul&gt;


&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;6. GET A BETTER PACKAGE MANAGER&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mxcl.github.com/homebrew/&quot;&gt;Get BREW first&lt;/a&gt;, follow the instruction on the web site of brew, after that it's all good&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ brew install git &lt;br/&gt;
  $ brew install wget &lt;br/&gt;
  $ brew install curl &lt;br/&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;Color the Terminal.app&lt;/strong&gt; for ls&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ vi ~/.bash_profile &lt;br/&gt;
  $ echo &quot;alias ls=&quot;ls -G&quot;&quot; &gt;&gt; ~./bash_profile
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;7. MYSQL&lt;/strong&gt; client can't be found after OSX 10.8 upgrade, it did not disappear  but for some reason, the PATH was messed up, it is still on &lt;em&gt;/usr/ocal/mysql/bin&lt;/em&gt;, just add it the SYSTEM PATH&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ vi ~/.bash_profile &lt;br/&gt;
  $ echo &quot;export PATH=$PATH:/usr/local/mysql/bin:.&quot; &gt;&gt; ~./bash_profile
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;8. PICTURES TAKEN IN PHOTOBOOTH&lt;/strong&gt; are in &lt;em&gt;~/Pictures/Photo Booth Library/Pictures&lt;/em&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;9. PANDOC&lt;/strong&gt; If you want to write in &lt;strong&gt;Markdown&lt;/strong&gt; then publish in HTML, PDF, Latex etc, you will need &lt;strong&gt;pandoc&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;First, you need to &lt;a href=&quot;http://www.haskell.org/haskellwiki/Mac_OS_X&quot;&gt;GET Haskell&lt;/a&gt;, you could try Fink or MacPort but the binaries worked best when I was doodling with this. There is a download link on &lt;a href=&quot;http://www.haskell.org/haskellwiki/Mac_OS_X&quot;&gt;HasKell Wiki&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Haskell installer would have installed the &lt;em&gt;cabal&lt;/em&gt; binaries at &lt;em&gt;~/.cabal/bin&lt;/em&gt;, add it to SYSTEM PATH then install pandoc&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ sudo cabal update
$ sudo cabal install pandoc
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;10. USE A BETTER TERMINAL CLIENT&lt;/strong&gt; Get &lt;a href=&quot;http://www.iterm2.com/&quot;&gt;Iterm2&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;11. PHP PEAR&lt;/strong&gt;. This is no longer included in 10.8, maybe it did not even make it in Leopard, I'm not sure. Just &lt;strong&gt;curl&lt;/strong&gt; it&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ curl http://pear.php.net/go-pear.phar &gt; go-pear.phar &lt;br/&gt;
$ sudo php -q go-pear.phar
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;PEAR installation will be at &lt;span class=&quot;codeblock&quot;&gt;~/pear/&lt;/span&gt;, bin, etc and all. Next, update your startup script&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ echo &quot;export PATH=$PATH:~/pear/bin:.&quot; &gt;&gt; ~/.bash_profile
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;12. PHAR &amp;amp; PHP COMPOSER&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Create a php.ini file first. OSX does have it at /private/etc. Don't copy the ini file somewhere else, it needs to be at &lt;em&gt;/private/etc/&lt;/em&gt;. Make sure that php.ini is actually in that directory&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ cd /private/etc &lt;br/&gt;
$ sudo cp php.ini.default php.ini
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Add the following to &lt;em&gt;php.ini&lt;/em&gt;, it's okay to add it at the very beginning, it
didn't give me problems that way&lt;/p&gt;

&lt;pre&gt;
detect_unicode = Off
date.timezone = YourCountry/YourCity
&lt;/pre&gt;


&lt;p&gt;After saving the update php.ini,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ cd /path/to/your/workarea &lt;br/&gt;
$ curl -s http://getcomposer.org/installer | php
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;composer.phar should be downloaded to &lt;code class=&quot;codeblock&quot;&gt;/path/to/your/workarea&lt;/code&gt;. Test it. &lt;span class=&quot;codeblock&quot;&gt; $ php composer.phar&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;13. EDITOR&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
$ brew install vim 
$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 
$ lynx https://gist.github.com/tedhagos/5916935 (say yes to the download)
$ tar -xzvf gistXXXXXX.tar.gz 
$ cp gistXXXX/.vimrc ~/.vimrc 
$ vim +BundleInstall +qall
&lt;/pre&gt;


&lt;p&gt;More details at &lt;a href=&quot;https://github.com/gmarik/vundle&quot;&gt;gmarik/vundle&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;14. GET A BETTER SCREEN MULTIPLEXER&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ brew install tmux
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There is a bit of a setup. You need to create ~/tmux.conf and create a script (the one that handles the shortcuts). The &lt;a href=&quot;https://gist.github.com/tedhagos/5917003&quot;&gt;tmux.conf and tdev.sh are here&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;


&lt;p&gt;&lt;strong&gt;15. COPY/PASTE ON THE CLI&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
$ cat somefile | pbcopy &lt;br/&gt;
$ echo pbpaste
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;16. USING A WINDOWS KEYBOARD ON MAC MINI&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Remap the keyboard for Mac Oriented use. Get the &lt;a href=&quot;http://doublecommand.sourceforge.net/&quot;&gt;Double Command Kernel Extension&lt;/a&gt;. Original instructions from &lt;a href=&quot;http://www.macworld.com/article/42446/2005/01/doublecommand.html&quot;&gt;MacWorld is found here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: F12 on the Win Keyboard is the eject button&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;17. RIP AUDIO CDS (FLAC)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I don't want to hear any &quot;But you can use iTunes to rip CDs&quot;. I know that. iTunes is very opinionated on how it wants to rip CDs and where to put them. I don't agree with it. Hence, the hacks.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ brew install cdparanoia &lt;br/&gt;
  $ brew install abcde &lt;br/&gt;
  $ touch ~/.abcde.conf
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;
  CDROM=/dev/disk1
  OUTPUTTYPE=flac
  INTERACTIVE=n
  PADTRACKS=y
  OUTPUTDIR=~/Music/abcde
  OUTPUTFORMAT='${ARTISTFILE}/${ALBUMFILE}/${TRACKNUM} - ${TRACKFILE}'
  VAOUTPUTFORMAT='Various/${ALBUMFILE}/${TRACKNUM} - ${TRACKFILE}'
  mungefilename ()
  {
    echo &quot;$@&quot; | sed s,:, -,g | tr /* _+ | tr -d '&quot;?[:cntrl:]
  }
&lt;/pre&gt;


&lt;p&gt;dev/disk1 is where my CD is mounted, find out where yours is mounted. A simple &lt;code class=&quot;codeblock&quot;&gt;df&lt;/code&gt; command should give you some clue where the CD drive is mounted. After that, ripping can start.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ diskutil unmount /dev/disk1 &lt;br/&gt;
  $ abcde &lt;br/&gt;
  $ diskutil eject /dev/disk1&lt;br/&gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The unmounting is necessary because abcde works with raw block devices and cannot function when the CD is mounted.&lt;/p&gt;

&lt;p&gt;I shamlessly ripped most of this guide from &lt;a href=&quot;http://hints.macworld.com/article.php?story=2005101620055677&quot;&gt;MacWorld contributed by extempore&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;17.1 RIP AUDIO CDS (MP3)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Get &lt;a href=&quot;http://sbooth.org/Max/&quot;&gt;MAX from SBooth&lt;/a&gt;. Work on the archive files and put in &lt;code class=&quot;codeblock&quot;&gt;/Applications&lt;/code&gt; folder or where you want. It's a GUI tool, so it's easy to work with.&lt;/p&gt;

&lt;p&gt;MAX uses musicbrainz.org for the CD metadata, the service is not good enough. GraceNotes, which is used by iTunes is more capable. The problem is, I couldn't find a direct way to connect MAX to GraceNotes. You need a bit of AppleScripting, this solution was the from the SBooth forums as well, the &lt;a href=&quot;http://forums.sbooth.org/viewtopic.php?f=4&amp;amp;t=1930&quot;&gt;link to the original discussion is here&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a Script in AppleScript, Save it anywhere you can find it easily. The script can be found on the link above (the sbooth forum), but I saved it in gist.github.com, here's the link https://gist.github.com/tedhagos/5845190&lt;/li&gt;
&lt;li&gt;When you insert the CD, iTunes will launch as well (you need this)&lt;/li&gt;
&lt;li&gt;Run the script you created. That will get the meta data of iTunes&lt;/li&gt;
&lt;li&gt;Rip Away&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This solution needs both iTunes and MAX running at the same time. When iTunes grabs the metadata from Gracenotes, the script grabs the metadata from iTunes&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;18. RIP DVDs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Just get &lt;a href=&quot;http://handbrake.fr/downloads.php&quot;&gt;Handbrake here&lt;/a&gt; you can figure out the rest&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;19. RIP YOUTUBE VIDEOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ brew install youtube-dl &lt;br/&gt;
  $ brew install ffmpeg &lt;br/&gt;
  $ brew install lame &lt;br/&gt;
  $ youtube-dl http://youtube-video-url
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There's a dedicated note for this &lt;a href=&quot;http://thelogbox.com/rip-youtube-videos-linux-osx/&quot;&gt;somewhere on thelogBox.com&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;20. ACCELERATE DOWNLOADING&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ brew install axel &lt;br/&gt;
  $ axel -n 5 protocol://resource-uri
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-n 5&lt;/strong&gt; means you want to use 5 simulateneous threads of download. Sample usage;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;
  $ axel -n 10 http://wordpress.org/latest.zip
&lt;/code&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;20. SQUEAKY CLEAN HARD DRIVE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Deleting stuff is easy, even applications. Just drag it to Trash can. Cleaning up left overs is the tedious part. It is not particulary difficulty, but annoying. Time is better employed somewhere else. There are better things to do than hunting down left over files; or worse, Googling about &quot;how to clean up your Mac&quot;, swimming through the internet cess pool and trying out blog guides (like the one you are reading). You cannot do that a lot. Just get &lt;strong&gt;Clean My Mac&lt;/strong&gt; or anything paid that catches your fancy. The Mac Store is a good place to start.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21. BACKUP Mail.App&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  $ mkdir MailBackup
  $ cd MailBackup
  $ cp -r ~/Library/Mail/V2/ .
&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;22. EXTERNAL DRIVES ARE IN&lt;/strong&gt; &lt;code class=&quot;codeblock&quot;&gt;~/Volumes/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23. REALLY SIMPLE MUSIC PLAYER&lt;/strong&gt; &lt;a href=&quot;http://cogx.org/&quot;&gt;CogX&lt;/a&gt;. There were others like Vox (didn't like it). WinAmp on OSX is no longer the WinAmp I remember from 10 years ago (I liked it then when it was simple) &amp;mdash; and iTunes just isn't for me. It won't let leave my Music organization alone&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Common Java Programming Errors</title>
   <link href="http://tedhagos.com /common-errors-java-programming"/>
   <updated>2004-08-26T00:00:00+08:00</updated>
   <id>http://tedhagos.com /common-errors-java-programming</id>
   <content type="html">&lt;h2&gt;SEMICOLON&lt;/h2&gt;

&lt;p&gt; A lot of your errors can really be solved by the semicolon. Java ignores white space, you need to tell it that your statement is finished by ending it with a semicolon.&lt;/p&gt;

&lt;p&gt;This isn't tricky to catch. The compiler is going to tell you where exactly you forgot the semicolon.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;RUNNING THE BYTECODE&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;java Hello.class&lt;/code&gt; is not the proper way to run a byte code. You do not include the &lt;em&gt;.class&lt;/em&gt; extension. You simply run it with &lt;code class=&quot;codeblock&quot;&gt;java Hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This error results in a &lt;em&gt;NoDefFoundException&lt;/em&gt;. This error is thrown when you try to use a class file that does not exist &amp;mdash; true enough, there is no &lt;em&gt;Hello.class&lt;/em&gt; class, there is only the &lt;em&gt;Hello&lt;/em&gt; class. Drop the extension of the filename when you want to run your program.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;FORGETTING MAIN&lt;/h2&gt;

&lt;pre&gt;
  class Hello {
    
  }
&lt;/pre&gt;


&lt;p&gt;This class will compile but it will not run. If you try to run &lt;code class=&quot;codeblock&quot;&gt;java Hello&lt;/code&gt;, you will get a &lt;em&gt;NoSuchMethodError main&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;main&lt;/em&gt; function is not a requirement for compilation but a requirement for runtime. Not all of your classes will need a &lt;em&gt;main&lt;/em&gt; but if you will run them on the command line, then they need a &lt;em&gt;main&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;
  class Hello {
    public static void main(String []args){
    }
  }
&lt;/pre&gt;


&lt;p&gt;This code will both compile and run.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;SPELLING AND CASING&lt;/h2&gt;

&lt;p&gt;Wrong spelling and type casing of the &lt;em&gt;main function&lt;/em&gt;. It should be &lt;code class=&quot;codeblock&quot;&gt;public static void main(String args[])&lt;/code&gt;.   Common variations of this mistake&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
Main(String args[])
Main()
main(string args[])
&lt;/pre&gt;


&lt;hr /&gt;

&lt;h2&gt;CURLY BRACES&lt;/h2&gt;

&lt;p&gt;Methods, Classes and Interfaces always will contain &lt;em&gt;blocks&lt;/em&gt;. Blocks are made up of a pair of curly braces &amp;mdash; they need to pair up. On trivial codes with just a few levels of nesting, this may not be an issue. On more involved codes with nested blocks, this will be a problem.&lt;/p&gt;

&lt;p&gt;This can be solved by practice and convention. If you use the &lt;em&gt;K &amp;amp; R&lt;/em&gt; way of french bracketing, then stick to it. Don't mix and match &lt;em&gt;C++ style&lt;/em&gt;  with K &amp;amp; R.&lt;/p&gt;

&lt;pre&gt;
  
      class Hello { // opening brace is here

      }
      
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;K &amp; R bracket&lt;/div&gt;




&lt;pre&gt;
  
      class Hello 
      { // opening brace is here

      }

&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;C++ style&lt;/div&gt;


&lt;p&gt;You can also move away from this problem quite easily by using a real programmer's editor. One that has facility to visually inspect paired curly braces and preferably one with &lt;em&gt;code folding&lt;/em&gt; abilities.&lt;/p&gt;

&lt;p&gt;Now you know one more reason why notepad is not a hard core programmer's editor. It's not a programmer's editor. At all. It never was.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;OBJECT COMPARISSON&lt;/h2&gt;

&lt;pre&gt;
class CompEqual {
  public static void main (String[] args) {
    String a = &quot;Hello&quot;; 
    String b = &quot;World&quot;;
    String c = a + b;

    System.out.println(c == (a + b)); // false
    System.out.println(c.equals(a + b)); // true
  }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Object Comparisson&lt;/div&gt;


&lt;p&gt;Use &lt;em&gt;==&lt;/em&gt; to compare primitive values. These things are stored on the &lt;em&gt;stack&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;When things are stored on the &lt;em&gt;heap&lt;/em&gt; &amp;mdash; all reference types are stored on the heap &amp;mdash; use the &lt;em&gt;.equals()&lt;/em&gt; method.&lt;/p&gt;

&lt;p&gt;Remember that &lt;em&gt;variable a&lt;/em&gt; does not really contain &quot;Hello&quot;. The string &quot;Hello&quot; is stored somewhere on the heap. What &lt;em&gt;variable a&lt;/em&gt; contains is the location of &quot;Hello&quot; in the heap. So when you compare &lt;em&gt;c == (a + b)&lt;/em&gt; you are not comparing the string contents, you are comparing memory addresses.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;ARRAY IS ZERO BASED&lt;/h2&gt;

&lt;pre&gt;
class Arr {
  public static void main (String[] args) {
    String arr[] = {&quot;Apple&quot;,&quot;Orange&quot;,&quot;Banana&quot;};
    for (int i =0; i &lt;= arr.length ; i++ ){
      System.out.print(arr[i]);
    } 
  }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;&lt; is not the same as &lt;=&lt;/div&gt;


&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;arr.length&lt;/code&gt; is = 3 but it doesn't mean that the last element's ordinal position is 3. The last element number is 2 because arrays start with 0 &amp;mdash; &lt;em&gt;0 - Apple, 1 - Orange, 2 - Banana&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This results to an &lt;em&gt;ArrayIndexOutOfBounds&lt;/em&gt; exception because the for loop is trying to access element number 3 of &lt;em&gt;arr&lt;/em&gt;, which there is none, it is only up to element number 2.&lt;/p&gt;

&lt;p&gt;The for loop above should have been written as &lt;code class=&quot;codeblock&quot;&gt;for(int i =0; i &amp;lt; arr.length)&lt;/code&gt; or &lt;code class=&quot;codeblock&quot;&gt;for(int i =0; i &amp;lt;= arr.length - 1)&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;EMPTY CATCH BLOCKS&lt;/h2&gt;

&lt;pre&gt;
try {
    DriverManager.getConnection();
    // some other statements here
}
catch(Exception e) {
    // NOTHING, ZILCH
}
&lt;/pre&gt;


&lt;p&gt;This is just plain laziness. You think you will have time to get around putting an actual handler later on? What happens when you  get so involved and immersed on other parts of the code. When your 50 liner code turns to 500, this will be very difficult to spot.&lt;/p&gt;

&lt;p&gt;When an actual error happens, the &lt;em&gt;catch&lt;/em&gt; block will activate and guess what happens. Nothing. Zilch. The error is suppressed. You sunk it down. Covered it up. Swept under the rug.&lt;/p&gt;

&lt;p&gt;As a rule of thumb, make errors scream and shout during development. You don't want it with a faint voice or no voice at all. It needs to grab your attention.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;TOO GENERIC EXCEPTION&lt;/h2&gt;

&lt;pre&gt;
try {
    Class.forName();
    DriverManager.getConnection();
}
catch(Exception e) {
    // SOME ERROR HANDLING CODES HERE
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;&lt;/div&gt;


&lt;p&gt;Yeah, this would work. &lt;em&gt;Exception&lt;/em&gt; is a very general class and all possible exceptions will be trapped by this one. Problem here is that when a SQLException occurs, do you think you can tell from the &lt;em&gt;Error Message&lt;/em&gt; that is something related to SQL. You will just get a very generic notification. This is just slightly better than &lt;em&gt;empty catch blocks&lt;/em&gt; &amp;mdash; like I said &amp;mdash; make the errors scream and shout. Really loudly.&lt;/p&gt;

&lt;p&gt;Use the specific exceptions for the catch blocks. If the code on the try block can throw SQLException and ClassCastException, then catch SQLException and ClassCastException. Not the generic &lt;em&gt;Exception&lt;/em&gt; class.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java Programming</title>
   <link href="http://tedhagos.com /java-programming"/>
   <updated>2004-02-18T00:00:00+08:00</updated>
   <id>http://tedhagos.com /java-programming</id>
   <content type="html">&lt;div class='notice'&gt;
  The Core Java Programming will no longer be updated. They will find a new home in thelogbox.com. 
&lt;/div&gt;




&lt;table&gt;
  &lt;th colspan=&quot;3&quot;&gt;DOCUMENT HISTORY&lt;/th&gt;
  &lt;tr&gt;
    &lt;td&gt;18 Feb 2004&lt;/td&gt;
    &lt;td&gt;0.1&lt;/td&gt;
    &lt;td&gt;CREATED&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;21 Oct 2007&lt;/td&gt;
    &lt;td&gt;0.2&lt;/td&gt;
    &lt;td&gt;REVISED. Covered Generics&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;12 Jun 2013&lt;/td&gt;
    &lt;td&gt;0.3&lt;/td&gt;
    &lt;td&gt;REVISED. Updated to Java 7&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;




&lt;h1 class=&quot;chapter&quot;&gt;INTRODUCTION&lt;/h1&gt;


&lt;p&gt;These are my notes on the Java Programming Language. These notes dates back to the late part of the 1990s. I update them from time to time. These were written primarily as a secondary reference for my students in Asia Pacific College and IBM ACE. It was not meant to be an introduction to computing concepts. It assumes that the reader has some degree of familiarization in basic programming concepts which may have been acquired from experience of another programming language.&lt;/p&gt;

&lt;p&gt;Having said that, what follows will take you through a very quick tour of the Java programming language. This material was not designed to cover all the aspects of the language, as it will be impractical to do so. The breadth and depth of Java, with all the associated technologies have increased drastically since it was first introduced in 1995.&lt;/p&gt;

&lt;p&gt;The code samples and exercises in this material were built using plain editors and the Java Development Kit. The use of simple tools is ideal for learning because there are no magic tricks and convenience facilities (like the case if you use an IDE). As a result, your brain will work harder because you are forced to use primitive tools. In a production environment or consulting environment, this reasoning might not be suitable and hence, the decision for tool selection will be influenced by other factors such as programmer productivity, time schedules and other constraints.&lt;/p&gt;

&lt;p&gt;For the purpose of learning programming in Java &amp;mdash; which is the goal of this material &amp;mdash; we need our brains and faculties to work harder than usual to maximize learning and understanding.&lt;/p&gt;

&lt;p&gt;Here we go.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;BEGINING TO PROGRAM&lt;/h1&gt;


&lt;p&gt;Before we ran, we learned to walk first. Before we walked, we needed to learn how to get up on our feet &amp;mdash; and way before that, we crawled.&lt;/p&gt;

&lt;p&gt;Before we build highly scalable web-endpoints or a flashy Android application, we need to do the crawling analog in Java. We need to learn how to write a basic program using the Java language. We need to discover the mechanics of compilation and runtime, what legal statements can we declare and their effects. We need to know how Java statements are organized, what kinds of control structures are available, what kinds of things we can create and manipulate.&lt;/p&gt;

&lt;p&gt;The goal for now is take a first step towards a very long road of programming. We need to learn how programs are constructed, what tools and with what materials should we construct them and finally, how should we run them.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;KEY CONCEPTS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Java is a compiled language.&lt;/strong&gt; You need to write the programming statements in a source file, compile them to produce an executable format or object code and finally run the executable file. If you did not make syntactical mistakes the source code will compile without problems. If you did commit syntactical errors then the compiler will not let you through, you will not be able to produce an executable format of your source program.&lt;/p&gt;

&lt;p&gt;A Java source file (also called a compilation unit) is a simple text file. You can use basic text editors to create and edit a source file. The choice for program editor is at best, a matter of preference. The only requirement for the text editor is it can write in ASCII format &amp;mdash; better yet if it can handle UNICODE. So pick any that catches your fancy.&lt;/p&gt;

&lt;p&gt;A Java source file will bear the extension .java, no matter which platform you are using. Don't worry that the extension doesn't follow the usual three letter format, the popular OS platforms can handle that kind of file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java is an Object Oriented language.&lt;/strong&gt; This has many consequences that affects you as a programmer, but right now, it affects what we can write inside our very first source file. You can write only classes and interfaces inside a source file. For our first example, we will write a class and not an interface &amp;mdash; interfaces are advanced constructs in Java, we will leave that for later. Inside classes, you can write variables, methods and program statements.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The source file cannot be ran directly on your platform.&lt;/strong&gt; It needs to be compiled. If you have installed the JDK (Java Development Kit) properly on your platform, you can already use the java compiler. The compiler takes on a source file (or source files) as an argument and turns them into executable files. These files do not have .com or .exe extensions, they have .class extensions instead.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You cannot run .class files directly on top of your OS.&lt;/strong&gt; Java executables run inside a special environment called the JRE (Java Runtime Environment). To run Java object files, you need to invoke the JRE and pass the name of the Java executable as a command line argument like this — &lt;code class=&quot;codeblock&quot;&gt;$ java executable_file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There are many kinds of Java programs. Some run on webservers (servlet &amp;amp; JSP), some inside browsers (applet) and some on mobile platforms (android). Some Java apps run on the desktop and there are two kinds of those, one with GUI and the other without &amp;mdash; these are called CLI or Command Line Interface applications. We will create a CLI app for this chapter.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/coding-process.png&quot;/&gt;&lt;/p&gt;

&lt;div id=&quot;cap&quot;&gt;Coding Process&lt;/div&gt;


&lt;p&gt;Before we begin writing programs, I suggest that you create a folder for purposes of trying out the samples in this material. It is best to name the folder without special characters or whitespace.&lt;/p&gt;

&lt;p&gt;Create a file named Hello.java. For now, just copy the contents from the sample code below&lt;/p&gt;

&lt;pre&gt;
  /**
   *
   * Our first program
   *
   * This is a block comment
   *
   * */
   
  class Hello {
     public static void main (String [] args) {
        System.out.println(&quot;Hello World\n&quot;);
     }
  }
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 1: Hello.java&lt;/div&gt;


&lt;p&gt;Compile the source file using &lt;code class=&quot;codeblock&quot;&gt;javac Hello.java&lt;/code&gt;. You will have a file named &lt;em&gt;Hello.class&lt;/em&gt; as a result of the compilation. Use the command &lt;code class=&quot;codeblock&quot;&gt;java Hello&lt;/code&gt;. Do not include the extension &lt;em&gt;.class&lt;/em&gt; when running Java programs, only the file name portion of the resulting &lt;em&gt;.class&lt;/em&gt; file is required.&lt;/p&gt;

&lt;p&gt;If you typed your program exactly as it appeared in Fig 1.1 the program should compile without problems. If you encountered any compilation error, to back to the program editor and check the  spelling of each and every word. Make sure you did not miss a curly brace or perhaps spelt &lt;code class=&quot;codeblock&quot;&gt;main()&lt;/code&gt; as &lt;code class=&quot;codeblock&quot;&gt;Main()&lt;/code&gt;. Java is case sensitive &amp;mdash; &lt;em&gt;main&lt;/em&gt; is different from &lt;em&gt;Main&lt;/em&gt;. When you are sure that the program is free from syntactical errors, compile it again, then run.&lt;/p&gt;

&lt;p&gt;The output of Fig 1 is a very uninteresting &quot;Hello World&quot;. True to tradition of every beginning programmer since Kernighan and Ritchie first started it on the first edition of the C Programming Language in 1969.&lt;/p&gt;

&lt;p&gt;Unexciting as the output maybe, it is simple yet rich enough to get our feet wet in Java programming. You need to get used to the structure of the Hello program because a lot of the codes you will write starts out this way.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;WHAT HAVE WE JUST DONE&lt;/h2&gt;

&lt;p&gt;The first seven lines of the Hello program are &lt;em&gt;comments&lt;/em&gt;. These are non-executable statements and you can put them anywhere &amp;mdash; inside or outside a class. You can write comments in three ways.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;//&lt;/code&gt;  &amp;mdash; This is an in-line comment, effective only on the current line. Anything to the right of this comment is ignored. This is suitable for commenting individual lines of code&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;/*   */&lt;/code&gt; &amp;mdash; This is a block comment, anything in between the inner asterisks will be ignored by the compiler. These can span multiple lines&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code class=&quot;codeblock&quot;&gt;/**   */&lt;/code&gt; &amp;mdash; Another block comment that is used by JavaDoc, don't worry about this right now. Just experiment with these three for the time being&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;After the comments is a class block. Everything inside the outermost pair of curly braces is the class block. Java is an OO language, and a strict one at that. You cannot write anything meaningul outside a class or interface. Even a simple output to the screen has to be within the context of a class. This is the reason why you need to be very comfortable with the structure of the Hello program as early as now or you will not go very far otherwise.&lt;/p&gt;

&lt;p&gt;A Java class is constructed using the keyword &lt;code class=&quot;codeblock&quot;&gt;class&lt;/code&gt; followed a &lt;em&gt;class name&lt;/em&gt;. The class name is something that you will define, in our example, the name of the class is &lt;em&gt;Hello&lt;/em&gt;. The class name is followed by a pair of curly braces. Anything inside the curly braces constitutes the body of the class.&lt;/p&gt;

&lt;pre&gt;
  
  // cannot write methods and variables here
  // only import, package statements and 
  // comments are allowed outside
  // the class 
  
  class Hello {
    // methods and variables goes here
  }
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 2: Basic Java class structure&lt;/div&gt;


&lt;p&gt;You might have noticed that our example class name is &lt;em&gt;Hello&lt;/em&gt; and that is stored in a file named &lt;em&gt;Hello.java&lt;/em&gt;. That is incidental and not a requirement at all. It would have been a requirement if we made the class &lt;em&gt;public&lt;/em&gt;. &amp;mdash; the &lt;em&gt;public&lt;/em&gt; keyword is an access modifier, but don't bother with that for the moment, you will have a chance to study its effects on coding later on.&lt;/p&gt;

&lt;p&gt;If we changed our construction to declare a public class, like in this&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  public class Hello {
    public static void main(String args[]) {

    }
  }
&lt;/pre&gt;


&lt;p&gt;then it becomes mandatory that the name of class be consistent with the name of the source file. There is a rule in Java programming that a source file can only contain, at most, one public class and if a class is defined as public in a source file, then name of the source file must be consistent with the name of the public class &amp;mdash; this is one of the many rules you need to be acquainted with Java.&lt;/p&gt;

&lt;p&gt;The name of the generated object file was &lt;em&gt;Hello.class&lt;/em&gt; not because the name of source file is &lt;em&gt;Hello.java&lt;/em&gt; but because the name of the class is &lt;em&gt;Hello&lt;/em&gt;. The name of class affects the name of the object file.&lt;/p&gt;

&lt;p&gt;Like most programming languages, a Java program needs an entry point. In this case, that is the &lt;code class=&quot;codeblock&quot;&gt;main()&lt;/code&gt; method &amp;mdash; a method and a function are technically the same. The semantic difference has got something to do with OOP philosophies. We won't bother with that right now, but you need to get used to the term method, rather than function.&lt;/p&gt;

&lt;p&gt;Having a &lt;em&gt;main&lt;/em&gt; method is not a requisite for compilation. It is a runtime requirement. Any class that you will pass on the JRE requires a main function. Not all classes will require this function, only those classes that you will use as a starting point of your program. In our example, class Hello is a program starting point.&lt;/p&gt;

&lt;p&gt;Java has a very specific format for a main function. The function needs to be &lt;em&gt;public&lt;/em&gt;, &lt;em&gt;static&lt;/em&gt; and &lt;em&gt;void&lt;/em&gt; &amp;mdash; these are reserved words in Java. Each have a specific action but we will defer their discussion for later.&lt;/p&gt;

&lt;p&gt;Inside the main function is &lt;em&gt;System.out.println()&lt;/em&gt; statement. This is a very common command in Java. You can practically put anything inside the parentheses and it will be printed to the screen. The string literal &quot;Hello World&quot; was placed inside the function &lt;em&gt;println()&lt;/em&gt;. String literals are defined be enclosing words using a pair of double quotation marks. You cannot define a string literal using single quotes &amp;mdash; that results into a different action.&lt;/p&gt;

&lt;p&gt;Lastly, all statements in a Java program are terminated by a semicolon. The white space in Java has no meaning. Indentations in Java also have no meaning, hence, you need to use the semicolon to intstruct the compiler that you are done with what you want to say. Best to keep this rule in mind, a lot of the first few rookie mistake you will make is because of the semicolon &amp;mdash; more precisely, the lack of it.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;EXERCISE TIME&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Create a Java program that prints out your name and email address on two separate lines.&lt;/li&gt;
&lt;li&gt;Create a Java program that prints outo your name and email address on two separate lines, but you can only use a single &lt;em&gt;println()&lt;/em&gt; statement.&lt;/li&gt;
&lt;li&gt;Play around with the source code of the Hello program. Try to compile and run. Record the results of the compilation and execution each time you make a change.&lt;/li&gt;
&lt;li&gt;Change the spelling of function main to Main&lt;/li&gt;
&lt;li&gt;Remove the opening curly brace immediately right after &lt;em&gt;main(String []args)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Change &quot;Hello World&quot; to &lt;em&gt;Hello\n.World&lt;/em&gt;. What's changed? Try to find out what the &lt;em&gt;\n&lt;/em&gt; means&lt;/li&gt;
&lt;/ol&gt;


&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;RESERVED WORDS&lt;/h1&gt;


&lt;p&gt;You will be defining a lot of things in Java. You will name your classes, variables and methods. There are only a few rules you need to observe when creating these names, one of these rules is to steer clear from reserved words or keywords.&lt;/p&gt;

&lt;p&gt;There are 50+ keywords in the Java language but not all of them are in use. The &lt;em&gt;const&lt;/em&gt; and &lt;em&gt;goto&lt;/em&gt; keywords are not in use. The keywords for Java has undergone some subtle changes over the years. There could also be some confusions regarding which keywords are treated as reserved words and which ones are simply literals for the language.&lt;/p&gt;

&lt;p&gt;In the past, the words &lt;em&gt;true, false&lt;/em&gt; and &lt;em&gt;null&lt;/em&gt; appeared as keywords . Sometime in the past, &lt;em&gt;null, true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt; have stopped being keywords and became known as literal values (From the Java Lang Spec). These are semantics and are probably of interest only to the language lawyers of Java. If your pursuits are more of the practical nature, I suggest not to bother with the semantic difference. The point is you cannot use keywords and literals as variable names or identifiers in your own code lest you will have a problem during compilation. This is the most important reason why you need to be familiar with them.&lt;/p&gt;

&lt;p&gt;It is always best to consult the most recent version of the Java Language Specification when it comes to these things because they are a matter of specification. The keywords are printed here only for ease of reference.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  abstract  continue    for             new           switch
  assert        default     goto            package     synchronized
  boolean       do            if                private     this
  break       double        implements  protected   throw
  byte        else        import          public        throws
  case        enum        instanceof    return      transient
  catch       extends       int short     try
  char        final       interface   static        void
  class       finally       long            strictfp    volatile
  const       float       native          super       while
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 3: Java KeyWords&lt;/div&gt;


&lt;p&gt;You do not need to memorize all the keywords now, but I think in time you will know them by heart as your practice grows.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;RULES ON WRITING IDENTIFIERS&lt;/h2&gt;

&lt;p&gt;Any programming construct that is programmer-defined is referred to as an &lt;em&gt;identifier&lt;/em&gt;. These are the things that you will need to name yourself.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;class name&lt;/li&gt;
&lt;li&gt;interface name&lt;/li&gt;
&lt;li&gt;method name&lt;/li&gt;
&lt;li&gt;name of a variable, name of parameters you pass to methods&lt;/li&gt;
&lt;li&gt;package name&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To create an identifier, there are certain rules that you must remember.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It must consist of alphanumeric characters&lt;/li&gt;
&lt;li&gt;It must not start with a number, but it can start with an underscore or a dollar sign&lt;/li&gt;
&lt;li&gt;It must not have any special characters inside it&lt;/li&gt;
&lt;li&gt;It must not be same as java keyword or literal&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;h2&gt;EXERCISE TIME&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;small number&lt;/li&gt;
&lt;li&gt;bignumber&lt;/li&gt;
&lt;li&gt;this-is-a-very-long-identifier_is-it-legal&lt;/li&gt;
&lt;li&gt;IsThisLegal?&lt;/li&gt;
&lt;li&gt;_IsThisLegal&lt;/li&gt;
&lt;li&gt;class_name&lt;/li&gt;
&lt;li&gt;import-no1&lt;/li&gt;
&lt;li&gt;transient&lt;/li&gt;
&lt;li&gt;volatile&lt;/li&gt;
&lt;li&gt;careful-this-is-volatile&lt;/li&gt;
&lt;/ol&gt;


&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;DATA TYPES&lt;/h1&gt;


&lt;p&gt;Programmers create things (data). We manipulate them by adding, substracting, dividing or multiplying. Sometimes we mash them up together (concatenation), then we create more things. Sometimes, we store these things for later use, and other times we don't, we simply discard them. Sometimes we dig up things that we have stored in the past (retrieval) and other times we show the things we've tucked away to other people (reports). This is an oversimplification of what programmers do, but I would guess that it is not very far from it.&lt;/p&gt;

&lt;p&gt;In order to create things, we need to know what kinds of things you can create. Will you be counting these things (whole numbers) or will you measure them (real numbers)? If we need to compare one thing to another thing, how will we  remember the result of that comparisson? Can we store the result of that comparisson inside another kind of thing, one that is aware of truth and falsity?&lt;/p&gt;

&lt;p&gt;If we were using a language that is pretty close to the metal, like assembly or C, you may need to know quite a bit about how things are stored and organized in a very low-level fashion before you can get very far.  We are, however, using Java and it will not require us to work close to the metal.&lt;/p&gt;

&lt;p&gt;You will work with &lt;em&gt;types&lt;/em&gt; rather than bits (zeroes and ones). Java has defined some useful abstractions for us already. These abstractions allow us to work with ease because we can represent familiar concepts with ready-made &lt;em&gt;types&lt;/em&gt;. For example, if you need to work with real numbers, Java has defined the &lt;em&gt;float&lt;/em&gt; and &lt;em&gt;double&lt;/em&gt;  data types. If you need to work with words and letters, Java has defined for us the &lt;em&gt;java.lang.String&lt;/em&gt; type.  These abstractions are high enough that we don't get bogged down by the details of how they are stored and structured on the disk, we can worry about other things like the logic of our application.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;byte&lt;/em&gt;  &amp;mdash; signed 8-bit integer (-128 to 127)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;short&lt;/em&gt; &amp;mdash;  signed 16-bit integer (-32,768 to 32,767)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;int&lt;/em&gt;   &amp;mdash; signed 32-bit integer (-2,147,483,648 to 2,147,483,647)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;long&lt;/em&gt;  &amp;mdash; signed 64-bit integer (-9,223,372,036,854,775,808 to 9,223,372,036,854,807)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;float&lt;/em&gt; &amp;mdash; signed 32-bit floating point (32 bit IEEE 754 floating point)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;double&lt;/em&gt; &amp;mdash; signed 64-bit floating point (64 bit IEEE 754 floating point)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;char&lt;/em&gt;  &amp;mdash; 16-bit Unicode character (0 to 65535 or \u0000 to \uFFFF)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;boolean&lt;/em&gt; &amp;mdash; either &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;h2&gt;HOW TO CREATE THINGS&lt;/h2&gt;

&lt;p&gt;Variables are created by declaring them, then defining them. For example,&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  int i;
&lt;/pre&gt;


&lt;p&gt;is a statement that DECLARES the variable named &lt;em&gt;i&lt;/em&gt;  that is of type &lt;em&gt;int&lt;/em&gt;, it does not define it however. To declare and define a variable, it done like this&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  int i;
  i = 0;
&lt;/pre&gt;


&lt;p&gt;In the preceding code, the variable &lt;em&gt;i&lt;/em&gt; was DECLARED on one line and then DEFINED on the following line. You can create your variables like this, or like this;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  int i = 0;
&lt;/pre&gt;


&lt;p&gt;Where the variable &lt;em&gt;i&lt;/em&gt; has been both declared and defined on the same line.&lt;/p&gt;

&lt;p&gt;Why are we specifying that &lt;em&gt;i&lt;/em&gt; is an int? That is because Java is a statically typed language. The compiler will not guess what kind of data you are creating, you have to tell it explicitly before it gets compiled.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;SOME TYPE RULES&lt;/h2&gt;

&lt;p&gt;The numerical types of Java follows a certain hierarchy &amp;mdash; &lt;em&gt;double&lt;/em&gt; is bigger than a &lt;em&gt;float&lt;/em&gt; which is bigger than a &lt;em&gt;long&lt;/em&gt; which is bigger than an &lt;em&gt;int&lt;/em&gt; which is bigger than a &lt;em&gt;short&lt;/em&gt; which is bigger than a &lt;em&gt;byte&lt;/em&gt;. You must be aware of this hierarchy because you will not always work with just one data type, exclusively &amp;mdash; you will work with a combination of them.&lt;/p&gt;

&lt;p&gt;For the most part, you can add variables of different types e.g. add an int to a double, a byte to an int etc, but you can only assign the value to a variable if the type of the value is;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the same as the type of the variable&lt;/li&gt;
&lt;li&gt;bigger than the type of the variable&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;For example&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  int a = 10;
  int b = a;
  long c = b;
  double d = c;
&lt;/pre&gt;


&lt;p&gt;You can assign &lt;em&gt;b to a&lt;/em&gt; because they are both int; assign &lt;em&gt;b to c&lt;/em&gt; because a long is bigger than an int; &lt;em&gt;c to d&lt;/em&gt; because a double is bigger than a long. Makes sense right? When you assign a smaller type to a larger type, that is what programmer's call a &lt;em&gt;upcast&lt;/em&gt;. Upcasting is automatically performed for you when you do operations like the above (assigning a smaller type to a larger type).&lt;/p&gt;

&lt;p&gt;Let's look at another example.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  byte a = 1;
  byte b = 2;
  byte c = a + b;
&lt;/pre&gt;


&lt;p&gt;It looks innocent and deceitfully accurate, but it will result to an error. While you may reason that  because we added 2 byte values (a + b), it stands that we should be able assign the arithmetic result to &lt;em&gt;c&lt;/em&gt; which is declared as a byte &amp;mdash; You would have been correct if the resulting type of adding two &lt;em&gt;byte&lt;/em&gt; values is also a byte, but that is not the case. One apple added to another another apple doesn't make two apples in this case. It looks counter-intrutive and scaringly frustrating to a beginner. I know. Don't panic. We just to understand the arithmetic rules of Java for this to make sense.&lt;/p&gt;

&lt;p&gt;Remember the hierarchy of types from a discussion a while ago &amp;mdash; &lt;em&gt;double&lt;/em&gt; is bigger than a &lt;em&gt;float&lt;/em&gt; which is bigger than a &lt;em&gt;long&lt;/em&gt; which is bigger than an &lt;em&gt;int&lt;/em&gt; which is bigger than a &lt;em&gt;short&lt;/em&gt; which is bigger than a &lt;em&gt;byte&lt;/em&gt; &amp;mdash; that one? It has a related rule.&lt;/p&gt;

&lt;p&gt;When a &lt;em&gt;double&lt;/em&gt; is added to something else, the resulting type is a double. When a &lt;em&gt;float&lt;/em&gt; is added to something else, the result is float. A &lt;em&gt;long&lt;/em&gt; added to something else, the result is a long. For everything else the result is an &lt;em&gt;int&lt;/em&gt;. Oh and by the way, I just used arithmetic &lt;em&gt;add&lt;/em&gt; operation for the explanation because it's a lot easier to say, but the truth is, that rule holds up for all arithmetic operation (+ - * / and %) &amp;mdash; that means no arithmetic operation will ever result into &lt;em&gt;short&lt;/em&gt; or a &lt;em&gt;byte&lt;/em&gt;. There is a very interesting reason for that rule, it sounds really clever too but that is out of the scope of this material. If you want to pursue that reason, dig up on &quot;how Java does arithmetic internally&quot;.&lt;/p&gt;

&lt;p&gt;Let's continue to work on our small byte addition example earlier, let's fix that.&lt;/p&gt;

&lt;pre&gt;
  class ByteAdd {
    public static void main(String args[]) {
      byte a = 1;
      byte b = 2;
      int c = a + b;
    }
  }
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 4: Adding two bytes&lt;/div&gt;


&lt;p&gt;And now, all is well.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;CASTING&lt;/h2&gt;

&lt;p&gt;You already know what &lt;em&gt;upcasting&lt;/em&gt; is, we discussed that not too long ago. Upcasting happens when you assign a narrow type to a wider type e.g. an &lt;em&gt;int&lt;/em&gt; value assigned to a &lt;em&gt;long&lt;/em&gt;. Java does for you automatically, no intervention needed. The opposite of &lt;em&gt;upcasting&lt;/em&gt; is of course, well, &lt;em&gt;downcasting&lt;/em&gt; &amp;mdash; not very creative, I know, but it makes the two terms easier to remember.&lt;/p&gt;

&lt;p&gt;Downcasting happens when you force a wider type into a narrow type e.g. try to assign an &lt;em&gt;int&lt;/em&gt; to a &lt;em&gt;byte&lt;/em&gt;, the compiler won't let you. Unlike upcasting, downcasting is an explicit activity. It needs action from the programmer.&lt;/p&gt;

&lt;p&gt;Let's go back to the byte arithmetic example of Fig 4. We solved that by making variable &lt;em&gt;c&lt;/em&gt; a int. We also could have solved that problem using downcasting.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  class ByteAdd {
    public static void main(String args[]) {
      byte a = 1;
      byte b = 2;
      byte c = (byte)(a + b);
    }
  }
&lt;/pre&gt;


&lt;p&gt;The cast operator is the pair of parentheses. We are forcing the value to the right of the cast operator, in this case &lt;code class=&quot;codeblock&quot;&gt;(a + b)&lt;/code&gt; which is a &lt;em&gt;int&lt;/em&gt; to become a &lt;em&gt;byte&lt;/em&gt;. You have to group expression &lt;em&gt;a + b&lt;/em&gt; because if you did not, only the value &lt;em&gt;a&lt;/em&gt; would have been casted to a byte, then the addition operation would be performed (which results to an int) then it will be assigned to &lt;em&gt;c&lt;/em&gt; &amp;mdash; the cast operator has a higher precedence than the addition operation, that is why you need to group.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;REFERENCE TYPE&lt;/h2&gt;

&lt;p&gt;By far and thus far, the data types you have seen are called &lt;em&gt;primitive types&lt;/em&gt;. The Java Type System has another kind of type. It is called &lt;em&gt;reference types&lt;/em&gt;. Let's defer the discussion for reference types at least until after we've gone through the OOP topic.&lt;/p&gt;

&lt;p&gt;For now, what we need to remember is that, if it's not primitive &amp;mdash; not a double, float, long, int, short, byte, char or boolean, then it must be a reference type. It' not all scary, some reference types are actually pretty to use e.g. the &lt;em&gt;String&lt;/em&gt; type, let's see some examples&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  String a = &quot;Hello&quot;;
  String b = &quot;World&quot;;
  String c = a + b;
  int d = 10;
  String e = a + d; // attention here
&lt;/pre&gt;


&lt;p&gt;I called your attention to the last line because I thought this might be a good opportunity to explain why the addition operator works for a String type, what happened to our rule before &amp;mdash; when a &lt;em&gt;double&lt;/em&gt; is added to something else it becomes a double.&lt;/p&gt;

&lt;p&gt;First, let's put an addendum to our rule. &lt;strong&gt;When something is added to a String&lt;/strong&gt; the whole expression becomes a String**. The String type rules them all.&lt;/p&gt;

&lt;p&gt;By the way, it's only the addition operator that is valid to a String type. You cannot substract a string from another string (not like numbers at least) nor can you divide or multiply Strings. The action of the &lt;em&gt;+&lt;/em&gt; operator on Strings is simply for concatenation.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1&gt;OPERATORS&lt;/h1&gt;


&lt;p&gt;This should not not be a long section. If you have programmed before using another language, chances are these operators are exactly the same thing in that other language that you used. So it's a not a big deal. There is not much to see here and to be honest, quite boring. So in this section, we will simply list the operators that you can use in Java. No gotcha's nor clever examples, just a list.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARITHMETIC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;+ - * / and %&lt;/em&gt; functions as you might expect. They work on numbers, both real and integral &amp;mdash; with the exception of the &lt;em&gt;+&lt;/em&gt; which also works on &lt;em&gt;Strings&lt;/em&gt; as you've seen earlier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COMPARISSON&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;&gt; &gt;=  &amp;lt; &amp;lt;= and ==&lt;/em&gt; are read, more than, more than or equal to,less than and less than or equal to, respectively. You know how to use them, you don't need me to explain.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOGICAL&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;amp;&lt;/em&gt; a logical &lt;em&gt;and&lt;/em&gt;. The expression will only be true if both operands are true&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt; a short circuit &lt;em&gt;and&lt;/em&gt;, more or less the same as the logical &lt;em&gt;and&lt;/em&gt; but it's short circuit. If the first operand is already false, it will not even bother testing the second operand, it will immediately return &lt;em&gt;false&lt;/em&gt;, hence it's name, short-circuit.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;|&lt;/em&gt; a logical &lt;em&gt;or&lt;/em&gt;. The expression will return true as long as one of the operand is &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;||&lt;/em&gt; a short-circuit or. It follows the same prinnciple as &lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt; only it performs it on an &lt;em&gt;or&lt;/em&gt; condition &amp;mdash; can you figure it out? That's your homework.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;There are other operators in Java, but we won't list them here. It makes sense to tackle them when there is more context. So we will leave the discussions of these other operators like &lt;em&gt;++ and --&lt;/em&gt; for later.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1&gt;FLOW OF CONTROL&lt;/h1&gt;


&lt;p&gt;Your ability to direct and command the flow of control in your program is one of the defining skills for a programmer. There are basically 3 ways that you can arrange the commands in your program code. You can execute commands one after another, &lt;em&gt;sequencing&lt;/em&gt;.
You can execute certain commands when certain conditions are met, &lt;em&gt;branching&lt;/em&gt;; and you can keep on repeating certain commands while certain conditions are still true, &lt;em&gt;looping or iteration&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;if statement&lt;/h2&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  if(condition) {
    statement 1;
    statement 2;
    statement n;
  }  
&lt;/pre&gt;


&lt;p&gt;The &lt;em&gt;if&lt;/em&gt; statement allows you to conditionally perform some commands. It allows you side-step the main flow of your code. If you remember your flowcharting concepts or logic formumation. When you see the diamond shape, it means you have a fork in the road. When a condition is met, you either go left or right. That is what the &lt;em&gt;if&lt;/em&gt; statement does. It allows you to test for conditions. When the condition is true, you go to the beginning of the if block (the opening curly brace) and begin executing all the statements there until all the statements are exhausted. When you have reached the end of the block (the closing curly brace), then there are no more commands to execute. The flow of control will resume immediately after the end of the curly brace.&lt;/p&gt;

&lt;p&gt;The condition in the &lt;em&gt;if&lt;/em&gt; statement can be written as expressions that will evaluate to either true or false. This is the most common use you will have of the if statement. On some occassions, you may see the condition written as the literals &lt;em&gt;true&lt;/em&gt; or &lt;em&gt;false&lt;/em&gt; -- this is rare, but it will still be a legal code. Looks easy, right.&lt;/p&gt;

&lt;p&gt;Okay, a little ice-breaker. Can you spot what's wrong in the next code. Try not to read the explanation and figure it out yourself first.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  int i = 0;
  if(i = 1) {
    System.out.println(&quot;but i is equal to one&quot;);
  }
&lt;/pre&gt;


&lt;p&gt;Did you catch it? If you did not, the Java compiler will. That's a good thing. People with programming experience in &lt;em&gt;C Language&lt;/em&gt; would be familiar with this, because the expression &lt;code class=&quot;codeblock&quot;&gt;if (i = 1)&lt;/code&gt; would have been valid in &lt;em&gt;C&lt;/em&gt;. Thankfully not in Java, the compiler would have warned you of &quot;Incompatible type error&quot;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;if&lt;/strong&gt; statement requires a boolean expession in the argument. The expression &lt;code class=&quot;codeblock&quot;&gt;(i = 1)&lt;/code&gt; will not result to a boolean expression, rather it will yield a integer expression; zero if the operation succeeds and non-zero if it fails.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;NESTING&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can put an if statement inside another if statement. You can in fact nest them up pretty deeply. While there is no set limit on how deep you can nest if statements, practical considerations and code readability should knock some sense into your code.&lt;/p&gt;

&lt;p&gt;From my experience, whenever I am treading dangerously deep into a web of if-else-if-else, that is usually a signal to take a step back and look if there are other ways of going about controlling program logic. It could be a design or analysis problem already and that using the if-else statement is not the right tool to solve the problem at hand.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;switch statement&lt;/h2&gt;

&lt;p&gt;When the nature of the decision you need to make is a bit on the fuzzy side, it could be impractical to use the if-statement, for those kinds of decisions, you will use the switch-statement.&lt;/p&gt;

&lt;p&gt;The syntax of the switch statement is;&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  switch(expression) {
    case CONSTANTEXPR:
    case ENUMCONSTANTNAME:
    default:
  }
&lt;/pre&gt;


&lt;p&gt;Where expression can either be a &lt;em&gt;char, byte, short, int&lt;/em&gt;. It can also be &lt;em&gt;Character, Byte, Short, Integer&lt;/em&gt; OR an &lt;em&gt;enum&lt;/em&gt; type. By the way, Character is not the same as char, that wasn't a typo. Character is a Java class which is a wrapper class for the char primitive. As of Java 7, you can now use String expressions on the &lt;em&gt;switch&lt;/em&gt; statement&lt;/p&gt;

&lt;p&gt;The following code sample  extracts the day-of-week value from a &lt;em&gt;Calendar&lt;/em&gt; object. The day-of-week is returned as integer, which makes it perfect to filter using a &lt;em&gt;switch&lt;/em&gt; statement rather than nested &lt;em&gt;if&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;
  import java.util.Calendar;

  class SwitchSample {

    public static void main(String args[]){

        Calendar now = Calendar.getInstance();
        int dow = now.get(Calendar.DAY_OF_WEEK);

        switch(dow) {
            case 0:
                System.out.println(&quot;Sunday&quot;);
                break;
            case 1:
                System.out.println(&quot;Monday&quot;);
                break;
            case 2:
                System.out.println(&quot;Tuesday&quot;);
                break;
            case 3:
                System.out.println(&quot;Wednesday&quot;);
                break;
            case 4:
                System.out.println(&quot;Thursday&quot;);
                break;
            case 5:
                System.out.println(&quot;Friday&quot;);
                break;
            case 6:
                System.out.println(&quot;Saturday&quot;);
                break;
            default:
                System.out.println(&quot;What the value really is = &quot; + dow);
            }
        }
  }
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 5: switch statement sample&lt;/div&gt;


&lt;p&gt;The switch is really simple to use, just put the expression which you'd like to test as an argument to the switch statement, then have a series of case statements inside the switch body.&lt;/p&gt;

&lt;p&gt;Each case statement corresponds to a value, if the value of the expression is equivalent to a case value, then instructions immediately right after the colon of the case statement will be executed/evaluated, in fact the rest of the statements will be evaluated, all the way down, until it gets to the last instruction at the bottom of the switch statement; that's not what your intention might be; that is the reason why I put a break statement. Once a case statement evaluates to true, Java blindly executes all the statements after that case, it won't even bother checking the other cases -- so note this, and be careful.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;while statement&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;while&lt;/em&gt; statement is used when you would like to perform some commands repeatedly, like in a loop. There is another statement in Java that does looping, that is the &lt;em&gt;for&lt;/em&gt; statement.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;while&lt;/em&gt; and &lt;em&gt;for&lt;/em&gt; loop may overlap at times because they have a similar function. For a beginner, it may not be quite obvious when to use one and not the other. The basic difference of the two statements though is that;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use the &lt;em&gt;while&lt;/em&gt; loop if you do not know how many times you need to loop&lt;/li&gt;
&lt;li&gt;Use the &lt;em&gt;for&lt;/em&gt; loop if you actually know how many times you will need to go through the loop&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;A &lt;em&gt;while&lt;/em&gt; loop looks like the following&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  while(condition) {
    statement 1;
    statement 2;
    statement n;
  }
&lt;/pre&gt;


&lt;p&gt;The &lt;em&gt;condition&lt;/em&gt; is either a literal (the keywords true or false) or an expression that will evaluate to either true or false (boolean values).&lt;/p&gt;

&lt;p&gt;The basic idea in a &lt;em&gt;while&lt;/em&gt; loop is this&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The condition is evaluated for the first time, if the condition is true or resolves to true, then;&lt;/li&gt;
&lt;li&gt;Perform statement 1, then;&lt;/li&gt;
&lt;li&gt;Perform statement 2, then;&lt;/li&gt;
&lt;li&gt;Perform statement n, then;&lt;/li&gt;
&lt;li&gt;The program detects that we are at the end of while block (the closing curly brace is the end of the while block)&lt;/li&gt;
&lt;li&gt;The program will loop back to the condition and re-evaluate it again, if it still true, then;&lt;/li&gt;
&lt;li&gt;Perform statement (again)&lt;/li&gt;
&lt;li&gt;rinse repeat until you get the end of the end of the block again and until you get to re-evaluate the condition (again).&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;You will only drop off end of the while block if and when the condition evaluates to false. This is the reason it is best to remember that you need write code inside the while block that will make the condition false at some point in time, lest you end up in a perpetual loop.&lt;/p&gt;

&lt;pre&gt;
  import static java.lang.System.out;

  class While {

      public static void main (String [] args){
  
          boolean condition = true;
          int counter = 0;

          while(condition) {
              out.println(counter);
              counter = counter + 1;
              if(counter &gt;10) {
                  condition = false;
              }
          }
      }
  }
&lt;/pre&gt;


&lt;p&gt;The sample code above shows the use of a while statement. Always remember to put something inside your while loop that will make the conditon false at some point in time. A perpetual loop can be very difficult for a beginning programmer to spot.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;for statement&lt;/h2&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  for(beginning value; ending value; step) {
      statement 1;
      statement 2;
      statement 3;
  }
&lt;/pre&gt;


&lt;p&gt;The &lt;em&gt;for loop&lt;/em&gt; like the &lt;em&gt;while&lt;/em&gt; allows you to iterate and perform a group of statements over and over again. The for loop though, allows for more control.&lt;/p&gt;

&lt;p&gt;A key concept in using the for loop is the automatic counter, the &lt;em&gt;step&lt;/em&gt;. The code will perform all the statements inside the block for a finite and determined number of times.&lt;/p&gt;

&lt;p&gt;Each time that the whole block is evaluated, the &lt;em&gt;step&lt;/em&gt; value is incremented. The incremented step value is then compared to the &lt;em&gt;ending value&lt;/em&gt;, and when the ending value is reached, the for loop will then terminate. The program control will fall over to first statement immediately after the for loop block.&lt;/p&gt;

&lt;pre&gt;
  class for_sample {

      public static void main (String [] args) {
          for(int i=0; i&lt;=10;i++) {
              System.out.println(i);
          }
      }
  }
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 6: Sample use of the for loop&lt;/div&gt;


&lt;p&gt;In the preceding example, we print some numeric values from zero (0) to ten (10). This is the exact thing that our &lt;em&gt;while&lt;/em&gt; example was doing earlier.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;break and continue&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; keywords disrupts program flow inside loops, whether the for-loop or while-loop.&lt;/p&gt;

&lt;pre&gt;
  while(condition) {
    statement 1;
    statement 2;
    break;
    statement 3;
    statement 4;
  }

  statement 5;
  statement n;
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 7: break inside a while loop&lt;/div&gt;


&lt;p&gt;The &lt;em&gt;break&lt;/em&gt; statement caused the program flow inside a block to forcibly exit. In the sample code (Fig 7), as soon as the &lt;em&gt;break&lt;/em&gt; statement is encountered, the program control ignored statements 3 and 4. The while loop will go out of scope and program control will be transferred to the first executable statement immediately after the while block -- in this case, statement 5.&lt;/p&gt;

&lt;p&gt;You normally will not use the &lt;strong&gt;break&lt;/strong&gt; statement in this fashion because it doesn't make sense. This statement is usually deployed with more logical finesse.&lt;/p&gt;

&lt;pre&gt;
  while(condition) {
    statement 1;
    statement 2;
    
    if(someCondition) {
        break;
    }   

    statement 3;
    statement 4;
  }

  statement 5;
  statement n;
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Fig 8: Another sample of break statement&lt;/div&gt;


&lt;p&gt;This is a more likely use of the &lt;em&gt;break&lt;/em&gt; statement. I should warn you though that this is a frowned upon practice. A truly structured programming should have only one entry point and one exit point. Because of the introduction the &lt;em&gt;break&lt;/em&gt; statement, our control structure now has one entry point and two exit points.&lt;/p&gt;

&lt;p&gt;While this code is innocent enough right now, it could get very hairy and complicated. You will appreciate following the 1-entry-1-exit rule when you have had your fair share of debugging someone else's code and you are wading through a maze of nested structures with lots of breaks peppered into the source code &amp;mdash; and by then you will understand why nobody wants to work on a code they did not write themselves.&lt;/p&gt;

&lt;p&gt;Next is the &lt;strong&gt;continue&lt;/strong&gt; keyword. Here is how it behaves.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
  while(condition) {
    statement 1;
    statement 2;
    continue;
    statement 3;
    statement 4;
  }

  statement 5;
  statement n;
&lt;/pre&gt;


&lt;p&gt;When the &lt;em&gt;continue&lt;/em&gt; statement is encountered, statements 3 and 4 will be ignored, just like how it was with the break. Unlike the case in &lt;strong&gt;break&lt;/strong&gt; though, the loop will not go out of scope and will not be immediately terminated.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;continue&lt;/em&gt; statement will go back to the beginning of the loop and forcibly re-evaluate condition. If the condition is still true, then the loop continues normally.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;ARRAYS&lt;/h1&gt;




&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;THE SIMPLEST PROGRAMS&lt;/h1&gt;


&lt;p&gt;Before going any further with dry definitions of program structure and rules, let's pause for a while. Take the time to exercise your new found knowledge of programming. Let's do some &lt;a href=&quot;http://c2.com/cgi/wiki?FizzBuzzTest&quot;&gt;fizzbuzz&lt;/a&gt; exercises&lt;/p&gt;

&lt;p&gt;A slight variation of the 'Hello World' program in Java. Take the time to read it. Try to see what is different about it.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
import static java.lang.System.*;

class Hello {

  public static void main (String[] args) {
    out.println(&quot;Another Hello&quot;);
  }
}
&lt;/pre&gt;


&lt;p&gt;The above code sample is different in two points:&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;import&lt;/em&gt; statement &amp;mdash; in most &lt;em&gt;Hello&lt;/em&gt; codes, the import statement is not needed. The package &lt;em&gt;java.lang.&lt;/em&gt; is imported by default, that is why you don't need it. The Simplest.java source code needed the &lt;em&gt;import&lt;/em&gt; statement because it is not a simple import. It is a &lt;em&gt;static import&lt;/em&gt;, it allows you to make unqualified calls to static members of a class &amp;mdash; &lt;em&gt;out&lt;/em&gt; is a static member of the &lt;em&gt;System&lt;/em&gt; class, it means we can simply say &lt;em&gt;out.println&lt;/em&gt; instead of fully qualifying the call like System.out.println. Okay, this may not be the simplest code because it involves static members which are discussed on the OOP lessons, but it doesn't mean we shouldn't take advantage of the short hand call&lt;/p&gt;

&lt;p&gt;The name of the source file is &lt;em&gt;Simplest.java&lt;/em&gt; but the name of the class is &lt;em&gt;Hello&lt;/em&gt;. There is no requirement for the name of the name of the class to be consistent with the name of the containing source file unless, the class defined has a &lt;em&gt;public&lt;/em&gt; scope.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;COMMAND LINE ARGUMENT&lt;/h2&gt;

&lt;p&gt;You can pass command line argument to java programs. Command line arguments allows a java program to get information from the session environment (cmd or SHELL), for example, try to invoke the &lt;em&gt;Hello&lt;/em&gt; class using this call &lt;code class=&quot;codeblock&quot;&gt;$ java Hello World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It did not result into any error, but it did not do anything new as well. That is because our code is not yet equipped of dealing with command line parameters. To deal with command line parameters, you need to access the &lt;em&gt;String&lt;/em&gt; array inside the &lt;em&gt;main()&lt;/em&gt; function&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
import static java.lang.System.*;

class Hello {

  public static void main (String[] args) {
    out.println(args[0]);
  }
}
&lt;/pre&gt;


&lt;p&gt;Run the program again with the command line parameters &lt;code class=&quot;codeblock&quot;&gt;$ java Hello World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This code works now because &lt;em&gt;main&lt;/em&gt; function of Java accepts a parameter, an array of &lt;em&gt;Strings&lt;/em&gt; and because all words (tokens) immediately after the name of Java executable is converted into an array of String. During runtime, you may access the contents of this array. Let's make one more change on the source code&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
import static java.lang.System.*;

class Hello {

  public static void main (String[] args) {
    out.println(&quot;Hello &quot; + args[0]);
  }
}
&lt;/pre&gt;


&lt;p&gt;Run the code one more time, but this time around, pass your name as the argument.&lt;/p&gt;

&lt;p&gt;You can concatenate Strings inside the &lt;em&gt;println()&lt;/em&gt; method, this helps out a bit when you are formatting the output a little bit. The arithmetic operator for addition works on Strings too, it adds the strings &amp;mdash; but it doesn't mean you can substract strings using the minus sign or divide or multiply. Only the + sign works on Strings&lt;/p&gt;

&lt;p&gt;Our code, while prints prettier than its previous versions, is still very fragile. It can break easily. Try to invoke it without any command line parameter and see what happens &amp;mdash; if you tried it, you probably have seen the &lt;em&gt;ArrayIndexOutOfBounds&lt;/em&gt; exception message. The reason for that is because our program blindly assumes that the user will always pass one command line parameter. It always assumes that the &lt;em&gt;args[0]&lt;/em&gt; will contain a valid data. That is why when you did not pass anything on the command line, args[0] does not contain anything, hence the error. To address that error, Let's make the code a bit defensive&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
import static java.lang.System.*;

class Hello {

  public static void main (String[] args) {

    if(args.length &gt; 0){
      out.println(&quot;Hello &quot; + args[0]);
    }
  }
}
&lt;/pre&gt;


&lt;p&gt;An array, like most things in Java is an object, which means it has methods and properties. It happens the &lt;strong&gt;length&lt;/strong&gt; property tells us the length of the array (how many elements it has). By doing a simple check if it the length of the array is more than zero, we can avoid the &lt;em&gt;ArrayIndexOutOfBounds&lt;/em&gt; error.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;ITERATING THROUGH COMMAND LINE PARAMETERS&lt;/h2&gt;

&lt;p&gt;The current version of our code is bit more sturdy than its previous versions, it won't break easily if you forgot to pass an argument on the command line. It can deal already with zero command line arguments, but what it cannot do is deal with more than one argument. If you pass more than one argument to the program, it simply echoes only the first argument. It does not know how to deal with more than one argument &amp;mdash; lets fix that.&lt;/p&gt;

&lt;pre&gt;
import static java.lang.System.*;

class Hello {

  public static void main (String[] args) {
    int length = args.length;
    for(int i=0; i &lt; length; i++){
      out.println(args[i]);
    }
  }
}
&lt;/pre&gt;


&lt;div id='cap'&gt;Simplest.java&lt;/div&gt;


&lt;p&gt;We've completely replaced the &lt;em&gt;if&lt;/em&gt; structure with a looping structure, the for loop. By using and iteration mechanism, it is unecessary to maintain the &lt;em&gt;if&lt;/em&gt; statement because the for-loop can also deal with zero argument.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;OBJECT ORIENTED PROGRAMMING&lt;/h1&gt;


&lt;p&gt;If you set out to truly understand how an automobile works, down to tiniest detail of how each nut and bolt performs, you could be in over your head &amp;mdash; especially if do not have a degree in mechanical engineering. On the other hand, if the goal is a simpler one such as &quot;to drive a car&quot;, it would seem to be a more achievable goal, by order of magnitudes. The mechanics of vehicle control such as steering, braking and accelerating are more manageable to keep in our heads as compared to principles of hydraulics or the inner workings of the internal combustion engine.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;COMPLEXITY&lt;/h2&gt;

&lt;p&gt;We are surrounded by complex systems in our daily lives, and a career in programming will not shield you from that &amp;mdash; au contraire. Our saving grace is that we have gotten pretty good at dealing with complexities. Take for example the plants that you have at home, you don't need to know the gory details of its biological structure in order to know that you need to give it some sun and water lest it will die. Another example is the light switch, you don't need a degree in electrical engineering to know that you if you flip the switch one way, its lights out &amp;mdash; flip it another way and its lights on.&lt;/p&gt;

&lt;p&gt;Computer scientist have grappled with complexities through the ages and have managed to develop tools to manage software complexities. One of the goals of complexity management is to engineer the illusion of simplicity &amp;mdash; to hide the working details of a complex system in order for it to be usable.&lt;/p&gt;

&lt;p&gt;There appears to be an inherent limit in the capabilities of our brain to deal with a swarm of information, we just can't deal with all of it &amp;mdash; at once. The silver lining, like I mentioned earlier is that we have gotten pretty good at dealing with an avalanche of information. We have developed a coping mechanism called &quot;abstraction&quot;&lt;/p&gt;

&lt;p&gt;A new employee on a large organization cannot and will not be able to comprehend all operational tasks that happens in the organization. He cannot possibly know the tiniest work details of each and every employee in the company. If you will just but give him a little time in the company, not only will be able to re-orient himself, he can also do something really productive that adds value to the company. So what happened between then and now? What makes us capable of navigating complex systems now but not then? The answer is, our minds oriented itself and adapted to its new environment.&lt;/p&gt;

&lt;p&gt;Our minds focused on just a few items while ignoring the other inessential details of the others. It then moved on to other parts of the complex system forming hierarchies of concepts that builds on top of one and then another. The information bottleneck was broken by dealing with it in chunks. When we focus on specific chunks, we are choosing to deal with idealized and generalized model of the object right in front of us \cite{ooad} thus increasing its semantic content. This abstraction process is responsible why we are capable of understanding very complex systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;KEY CONCEPTS&lt;/h2&gt;

&lt;p&gt;There are a couple of criteria that a programming language needs to meet before it can be considered a OOP language. It needs provide a facility to effectively implement the process of &lt;em&gt;abstraction&lt;/em&gt;. It needs to provide a way to reuse functionality by means of extension &amp;mdash; &lt;em&gt;inheritance&lt;/em&gt;. It needs to have a mechanism to protect data and type from inadvertent and unintentional state changes &amp;mdash; &lt;em&gt;encapsulation&lt;/em&gt;. It needs to have a mechanism to effect &lt;em&gt;polymorphism&lt;/em&gt; and it needs to have a mechanism for grouping some programming constructs such as methods and classes &amp;mdash; &lt;em&gt;encapsulation&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;ABSTRACTION&lt;/h3&gt;

&lt;p&gt;Abstraction is an activity where the essential characteristics of &lt;em&gt;something&lt;/em&gt; is distilled. It makes that something different from other somethings. For example, if you think hard about an elevator and try to list down the characteristics, what would they be? How is an elevator different from other modes of transport such as an escalator or a conveyor?&lt;/p&gt;

&lt;p&gt;We cannot simply list &lt;em&gt;move up&lt;/em&gt; and &lt;em&gt;move down&lt;/em&gt;, while these set of behaviors differentiate the elevator from the conveyor (which simply moves to the left and to the right), it does not differentiate it effectively from an escalator. Even if we incorporate the idea that an elevator stops in between floors, it still does not differentiate it because the escalator also takes us from floor to floor. We can incorporate the behavior of &lt;em&gt;skipping floors&lt;/em&gt; and that will be an effective differentiator because an escalator cannot skip floors.&lt;/p&gt;

&lt;p&gt;If we summarize the &lt;em&gt;behavior&lt;/em&gt; of the elevator, we can come up with two,  &lt;em&gt;moveDownToFloor()&lt;/em&gt; and &lt;em&gt;moveUpToFloor()&lt;/em&gt;. That is the essence of an elevator object. The tricky part is how to know when to stop adding or removing behavior from an object. Unfortunately, abstraction is an acquired skill, and you can only get better at it overtime if you do it lots of times.&lt;/p&gt;

&lt;p&gt;I can tell you from practice that abstraction is not so much as identifying a thousand (unimportant) behavior for an object. On the contrary, abstraction is more an exercise on reduction. Try to remove behavior from an object until you are down to a bare minimum. Let's take a shoe object for an example. You can remove the heels of a shoe and it still will be a shoe. You can remove the laces and it still (barely) is a shoe &amp;mdash; but you cannot remove its sole.&lt;/p&gt;

&lt;p&gt;The abstracted list of behavior of an object is known as a &lt;em&gt;Type&lt;/em&gt; &amp;mdash; this is an important terminology in OOP and Java, that is why I am emphasizing it in this section. All objects in Java &lt;strong&gt;must have at least one type&lt;/strong&gt; &amp;mdash; it can have more, but not less.&lt;/p&gt;

&lt;h3&gt;TYPE SYSTEM&lt;/h3&gt;

&lt;p&gt;It might help if you think of a &lt;em&gt;Type&lt;/em&gt; as some sort of a contract or a promise from an object. The object is making a committment that it will respond to any other object or program who calls anyone of the methods within this type. Going back to the elevator example, it means that any Java object or program can call &lt;em&gt;elevator.moveDownTo()&lt;/em&gt; or &lt;em&gt;elevatorMoveUpTo()&lt;/em&gt; and they are guaranteed to get a response.&lt;/p&gt;

&lt;p&gt;There are three ways to define a Type in Java, the &lt;em&gt;class&lt;/em&gt;, &lt;em&gt;abstract class&lt;/em&gt; and &lt;em&gt;interface&lt;/em&gt;. Each has its own strengths and inconveniences.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;OBJECTS, CLASSES AND TYPES&lt;/h2&gt;

&lt;p&gt;An object is an abstraction of something useful to you (the programmer). An object represents an idealized and generalized model of something of interest. Take for example a Phone object, its protocols could be abstracted as &lt;em&gt;answerCall()&lt;/em&gt; and &lt;em&gt;dialNumber()&lt;/em&gt;. If we skip all the programming details of type creation, we can start using the object in a Java program , like in the following code.&lt;/p&gt;

&lt;pre&gt;
    Phone phone = new Phone();
    phone.answerCall();
    phone.dialNumber(&quot;6321234567&quot;);
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;Phone&lt;/em&gt; with an uppercase first letter is a type declaration and &lt;em&gt;phone&lt;/em&gt; all lowercase letter is variable of type &lt;em&gt;Phone&lt;/em&gt;. In the statement &lt;code class=&quot;codeblock&quot;&gt;int i=1;&lt;/code&gt; &lt;em&gt;int&lt;/em&gt; is the type and &lt;em&gt;i&lt;/em&gt; is a variable of type integer. The &lt;em&gt;new&lt;/em&gt; keyword is responsible for creating the Phone object and &lt;em&gt;Phone()&lt;/em&gt; is a special method called a &lt;em&gt;constructor&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;To invoke the behavior of an object, you simply need to call its method using the dot notation. That is what we did in the statements &lt;em&gt;phone.answerCall()&lt;/em&gt; and &lt;em&gt;phone.dialNumber()&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Objects are made by instantiating &lt;em&gt;Classes&lt;/em&gt;, they our primary we will use to achieve abstraction. If we were to codify the Phone program in our example, it could look like the following:&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
class Phone {
  String phonenumber=&quot;6321234567&quot;;
    
  void answerCall() {}
  void dialNumber(String args) {}
    }  
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;Phone.java&lt;/em&gt; is a Java class. It is constructed by using &lt;em&gt;class&lt;/em&gt; keyword followed by a name of the class .The open and close curly brace is the body of the class.&lt;/p&gt;

&lt;p&gt;You can define methods and variables inside the class body. The collection of methods inside the class body constitutes the protocols of the object. They are the set of behavior that the Phone object guarantees to respond to.&lt;/p&gt;

&lt;p&gt;Java classes are written on source files. Ideally one class definition per source file but you can define more than one class in a file. Classes are compiled using &lt;code class=&quot;codeblock&quot;&gt;javac sourcefile.java&lt;/code&gt; command, in our case, &lt;code class=&quot;codeblock&quot;&gt;java Phone.java&lt;/code&gt;. This will produce a file named &lt;em&gt;Phone.class&lt;/em&gt;, it is the compiled version of Phone.java. A compiled class is a requirement before you can instantiate objects.&lt;/p&gt;

&lt;p&gt;Let's summarize in code what we've discussed so far.&lt;/p&gt;

&lt;pre&gt;
    import static java.lang.System.out;

    class Phone {
    String phonenumber=&quot;6321234567&quot;;
   
    void answerCall() {
        out.println(&quot;Answering call...&quot;);
    }
    void dialNumber(String args) {
        out.println(&quot;Calling &quot; + args);
    }
    void setPhoneNumber(String args) {
        phonenumber = args;
    }
    }

    class PhoneTest {

    public static void main (String [] args) {
        Phone p1 = new Phone();
        p1.answerCall();
        p1.dialNumber(&quot;6329876543&quot;);
      
        Phone p2 = new Phone();
        p2.answerCall();
        p2.dialNumber(&quot;6327778888&quot;);
    }
    }
  
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Phone.java&lt;/div&gt;


&lt;p&gt;The PhoneTest program shows a more complete example of how you might use the Phone object. The PhoneTest class is not necessary because the &lt;em&gt;main()&lt;/em&gt; function could have been easily written inside Phone class, but the verbosity of two classes was chosen to make the example more readable and less confusing for beginner programmers.&lt;/p&gt;

&lt;h3&gt;INSTANTIATION&lt;/h3&gt;

&lt;p&gt;To create an object, you need to instantiate a class. The resulting object now has the protocols or the &lt;em&gt;Type&lt;/em&gt; of that class. You can begin using the object according to the protocols that was defined by its class. The protocols needs to be followed strictly, if the method defined is &lt;em&gt;dialNumber(String args)&lt;/em&gt;, you need to call the method exactly as it was defined. The spelling needs to be right, the casing of the letters needs to be right and if the method expects an argument or parameter to be passed, you need to pass the expected parameter, in the case of the &lt;em&gt;dialNumber&lt;/em&gt; method, it expects a String parameter.&lt;/p&gt;

&lt;p&gt;The PhoneTest program defines the &lt;em&gt;setPhoneNumber()&lt;/em&gt; method and the &lt;em&gt;phonenumber&lt;/em&gt; variable. The class initially defines its own phone number via the phonenumber variable, but it also offers a way to change this phone number. The &lt;em&gt;setPhoneNumber&lt;/em&gt; method was declared to facilitate a way to change an internal detail of the class. If the &lt;em&gt;setPhoneNumber&lt;/em&gt; method is called passing a new phone number, the object's state will change. It will have a new phone number.&lt;/p&gt;

&lt;h3&gt;ENCAPSULATION&lt;/h3&gt;

&lt;p&gt;Classes provides a way to package data and behavior in a single construction. The &lt;em&gt;phonenumber&lt;/em&gt; variable is not foreign or external to &lt;em&gt;Phone Type&lt;/em&gt;, it is an instrinsic property of the Phone. The &lt;em&gt;setPhoneNumber&lt;/em&gt; method is also intrinsic to the Phone. If you invoke the &lt;em&gt;setPhoneNumber&lt;/em&gt; method, it will act on a data that belongs to the Phone object, not something alien to the Phone. Java enforces this kind of encapsulation in a strict fashion. There is no way to define a stand-alone method or a stand-alone variable, every method and every variable needs to be associated with a &lt;em&gt;Type&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The concept of objects, classes and types are intertwined. Understanding these concepts individually and collectively forms one of the basis of effective Java programming.&lt;/p&gt;

&lt;p&gt;Objects are created from classes. You cannot create an object without a class definition. When you create an object, the process is known as &lt;em&gt;instantiation&lt;/em&gt;. An instantiated class &amp;mdash; an object &amp;mdash; can respond to messages or methods as long as the methods are within the defined protocols of the class.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;Type&lt;/em&gt; is a collection of methods. One way to define a &lt;em&gt;Type&lt;/em&gt; is to define a class &amp;mdash; there are two other ways but they will be deferred for later discussion. It is not correct to say that a class has a type. It is correct to say that a class is a Type, just as it is correct to say that an object has a Type &amp;mdash; the Type that was defined by the class.&lt;/p&gt;

&lt;p&gt;To illustrate the relationship between a class and an object, try imagining a house plan, a blueprint if you may &amp;mdash; the kinds of drawings that architects produce before building a house. If we build one house out of an architect's blueprint, we can say that the physical house that was built is an instance of the blueprint.&lt;/p&gt;

&lt;p&gt;If we build another house using the same architect's blueprint, we can say that the second house is another instance of the architect's blueprint. Now there are two houses built from the same blueprint. Even if the two houses will be identical because of their structural similarities, they are actually two distinct houses, they are not one and the same. They will be inhabited by different people, they may differ in roof colors or interior paints etc. That is exactly what's going on as well between &lt;em&gt;classes&lt;/em&gt; and &lt;em&gt;bjects&lt;/em&gt;. Classes are the blueprints from whence objects come from.&lt;/p&gt;

&lt;p&gt;Going back to the Phone example, if we wanted to create other Phone objects, we simply need to instantiate the Phone class again.&lt;/p&gt;

&lt;pre&gt;
    import static java.lang.System.out;

    class Phone {
    String phonenumber=&quot;6321234567&quot;;
    void answerCall() {
        out.println(&quot;Answering call...&quot;);
    }
    void dialNumber(String args) {
        out.println(&quot;Calling &quot; + args);
    }
        void setPhoneNumber(String args) {
        phonenumber = args;
    }
    }

    class PhoneTest {

      public static void main (String [] args){
      Phone p1 = new Phone();
      p1.answerCall();
      p1.dialNumber(&quot;6329876543&quot;);
      
      Phone p2 = new Phone();
            p2.setPhoneNumber(&quot;6329995555&quot;);
      p2.answerCall();
      p2.dialNumber(&quot;6327778888&quot;);
    }
    }
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Phone.java&lt;/div&gt;


&lt;h3&gt;STATE ENCAPSULATION&lt;/h3&gt;

&lt;p&gt;The variables &lt;em&gt;p1&lt;/em&gt; and &lt;em&gt;p2&lt;/em&gt; are both of type Phone but they are two distinct objects. They have two different states (phone numbers). You can manipulate one phone object without impacting the state of the other. This characteristic of objects allows for a more sane and rational programming environment.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;CONSTRUCTORS&lt;/h2&gt;

&lt;p&gt;Object creation requires four things, the type of object to be created, a variable to store the reference of the created object, the &lt;em&gt;new&lt;/em&gt; keyword to effect the actual creation and a &lt;em&gt;constructor&lt;/em&gt;. You have seen and used all these things with the exception of the last one, the constructor. In the statement &lt;code class=&quot;codeblock&quot;&gt;Phone p1 = new Phone()&lt;/code&gt;, &lt;em&gt;Phone&lt;/em&gt; is the type and &lt;em&gt;Phone()&lt;/em&gt; is the constructor.&lt;/p&gt;

&lt;p&gt;A constructor call is a method, first and foremost but it is not an ordinary method. It is special because it bears the same name as that of the class where it is declared and unlike ordinary methods, it is not written with a &lt;em&gt;return type&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Constructors are important, you cannot create objects without them. They are of extreme importance that Java will actually supply a default constructor in case you do not provide one explicitly.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
    class Phone {

        public static void main(String []args) {
            Phone p1 = new Phone();
        }
    }
&lt;/pre&gt;


&lt;p&gt;In the preceding code sample, we did not define an explicit constructor but we were still able to call &lt;code class=&quot;codeblock&quot;&gt;new Phone()&lt;/code&gt;. The reason for this is because Java supplied our code with a default &lt;em&gt;no-arg constructor&lt;/em&gt; (no argument constructor). As if we had written something like&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
    class Phone {

        Phone() {
        }

        public static void main(String []args) {
            Phone p1 = new Phone();
        }
    }  
&lt;/pre&gt;


&lt;p&gt;There is also no &lt;em&gt;return&lt;/em&gt; statement within the body of the constructor. When the constructor returns, it will create an object of type Phone, the variable &lt;em&gt;p1&lt;/em&gt; will hold a reference (an address) to actual Phone object.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;INHERITANCE POLYMORPHISM&lt;/h2&gt;

&lt;p&gt;A class can re-use all the codes and functionalities of another class by means of extension. The class being extended is typically called the &lt;em&gt;parent class&lt;/em&gt; (sometimes also called super class or base class) and the extending class is called a &lt;em&gt;child class&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Class extension grants the child class all the inheritable methods and variables of the super class. The instant functionality gained from class extension impacts the productivity of the programmer in a positive way. If the abstractions are done carefully and rationally, it becomes possible to write a piece of code that can be used in other applications.&lt;/p&gt;

&lt;pre&gt;
    import static java.lang.System.out;

    class Telephone {
        String phonenumber;
    
        void init() {
            out.println(&quot;connecting to carrier via land line&quot;);
        }
        void dialNumber(String args) {
            out.println(&quot;Dialling &quot; + args);
        }
        void answerCall() {
            out.println(&quot;Answering call...&quot;);
        }   
    }

    class MobilePhone extends Telephone {}

    class TelephoneTest {

        public static void main(String[] args) {

            MobilePhone mp = new MobilePhone();

            mp.init();
            mp.dialNumber(&quot;6327775566&quot;);
            mp.answerCall();

        }
    }
&lt;/pre&gt;


&lt;h3&gt;EXTENDS&lt;/h3&gt;

&lt;p&gt;In the sample code, the &lt;em&gt;MobilePhone&lt;/em&gt; type was created by defining a class. The class block does not contain any definition and yet we were able to call the &lt;em&gt;init&lt;/em&gt;, &lt;em&gt;dialNumber&lt;/em&gt; and &lt;em&gt;answerCall&lt;/em&gt; methods against it &amp;mdash; these methods, though not explicitly defined inside the &lt;em&gt;MobilePhone&lt;/em&gt; class has been inherited from the &lt;em&gt;Telephone&lt;/em&gt; class. The &lt;em&gt;extends&lt;/em&gt; keyword is used to denote that one class is inheriting from another class.&lt;/p&gt;

&lt;h3&gt;JAVA'S ROOT CLASS&lt;/h3&gt;

&lt;p&gt;Class extension is not an optional activity in Java programming. A Java class needs to extend &lt;em&gt;at least and at most&lt;/em&gt; one other class. All newly defined classes, by default, extends the &lt;em&gt;java.lang.Object&lt;/em&gt; class, unless otherwise overriden by an explicit &lt;em&gt;extends&lt;/em&gt; declaration. In Listing 4.5, class Telephone is not explicitly extending any class, hence it is a child class of &lt;em&gt;Object&lt;/em&gt;--it is as if we had written;&lt;/p&gt;

&lt;pre&gt;
    class Telephone extends Object {

    }
    class MobilePhone extends Telephone {

    }  
&lt;/pre&gt;


&lt;p&gt;&lt;em&gt;MobilePhone&lt;/em&gt; does not extend &lt;em&gt;Object&lt;/em&gt; because we declared explicitly that it extends Telephone. You will realize soon enough that every class in Java descends either directly or indirectly from &lt;em&gt;java.lang.Object&lt;/em&gt;. It is the root class of all objects in Java&lt;/p&gt;

&lt;h3&gt;SINGLE ROOTED INHERITANCE&lt;/h3&gt;

&lt;p&gt;I would not advise that you explicitly declare all your classes to extend from Object. Firstly because Java will do that for you implicitly and secondly because you can only extend one class. There is no way to achieve multiple class inheritance. Java follows a single-rooted class inheritance, once you have extended a class, you cannot inherit from another one. That is not to say multiple inheritance cannot be achieved in Java, it can be, using &lt;em&gt;interfaces&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;INTERFACES&lt;/h3&gt;

&lt;p&gt;Creating a class is one of three ways to define a &lt;em&gt;Type&lt;/em&gt;. The second way is to create an &lt;em&gt;interface&lt;/em&gt;. An interface is the purest form of a type because it only contains the protocols but not the implementing details of the object. The class on the otherhand contains both the protocol (the Type) and the implementing details (body of the functions).&lt;/p&gt;

&lt;pre&gt;
    interface Phone {
        void answerCall();
        void dialNumber(String args);
    }
&lt;/pre&gt;


&lt;p&gt;An interface is declared using the &lt;em&gt;interface&lt;/em&gt; keyword followed by a name ^[The name of interfaces are programmer defined, like the class]. The opening and closing curly braces comprises the body of the interface.&lt;/p&gt;

&lt;p&gt;Methods are variables can be declared in an interface, but they are not the kind of variables and methods that you would declare insie the class. Interfaces can only contain &lt;em&gt;abstract methods&lt;/em&gt;, which makes sense because interfaces are supposed to contain only the Type information and not the implementation detail. An abstract method declares only the method signature ^[Method signature is the return type, name of the method and parameters that it accepts] and has a semi-colon immediately right after, in place of the usual method body. If you declare variables inside the interfaces, they will be automatically &lt;em&gt;final, static&lt;/em&gt; and &lt;em&gt;public&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;
    interface IPhone {
        void answerCall();
        void dialNumber(String args);
    }

    class Phone implements IPhone {
        public void answerCall() {
            System.out.println(&quot;Answering call&quot;);
        }
        public void dialNumber(String args){
            System.out.println(&quot;Calling &quot; + args);
        }

        public static void main(String[] args) {
            Phone p = new Phone();
            p.dialNumber(&quot;632444888&quot;);
            p.answerCall();
        }
    }
&lt;/pre&gt;


&lt;p&gt;Interfaces are not meant to be instantiated, they are meant for type extensions (inheritance). To use interfaces, they must be &lt;em&gt;implemented&lt;/em&gt; by a class. The code sample of listing 4.7 shows a Phone class inheriting the type &lt;em&gt;IPhone&lt;/em&gt; using the &lt;em&gt;implements&lt;/em&gt; keyword.&lt;/p&gt;

&lt;h3&gt;INHERITING FROM AN INTERFACE BINDS YOU TO A CONTRACT&lt;/h3&gt;

&lt;p&gt;When you implement an interface, you are entering into a contract, that you will &lt;em&gt;implement&lt;/em&gt; whatever methods you have inherited. Implementing a method means that you will provide the details of the function. You will supply the function body.&lt;/p&gt;

&lt;p&gt;At first glance, it looks like more work for the programmer because you are duplicating code. First you will write the interface but the methods doesn't have details, then you will implement in a class then supply the details of the method. This argument maybe true for trivial applications ^[I would define a trivial application as something that you don't intend to maintain or improve in the course of years. A disposable application], but for non-trivial applications, coding against an interface rather than a concrete class is good way to use the Java typing system to achieve maintainability of code. Another reason to use interfaces is when you truly need multiple inheritance. Let us expand the Phone program.&lt;/p&gt;

&lt;pre&gt;

    import static java.lang.System.out;

    interface Printer {
        void print();
    }

    interface Phone {
        void answerCall();
        void dialNumber(String args);
    }
  
    interface Copier {
        void copy();
    }

    class MultiFunction implements Printer, Phone, Copier {
        public void print() {
            out.println(&quot;Printing&quot;);
        }
        public void answerCall() {
            out.println(&quot;Answering call&quot;);
        }
        public void dialNumber(String args) {
            out.println(&quot;Dialling &quot; + args);
        }
        public void copy() {
            out.println(&quot;Copying&quot;);
        }   
    }

    class TestMultiFunction {

        public static void main(String[] args) {
            Printer printer = new MultiFunction();
            Phone phone = new MultiFunction();
            Copier copier = new MultiFunction();
        
            printer.print();
            phone.answerCall();
            copier.copy();
        
            System.out.println(copier.toString());
            copier.print();
        }
    }
  
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;MultiFunction.java&lt;/div&gt;


&lt;p&gt;The &lt;em&gt;Multifunction.java&lt;/em&gt; code defines three interfaces, the &lt;em&gt;Phone&lt;/em&gt;, &lt;em&gt;Printer&lt;/em&gt; and the &lt;em&gt;Copier&lt;/em&gt;. The class &lt;em&gt;MultiFunction&lt;/em&gt; implements all three interfaces.&lt;/p&gt;

&lt;p&gt;This code is saying that &amp;mdash; MultiFunction &lt;em&gt;is a&lt;/em&gt; Printer, it &lt;em&gt;is also a Copier&lt;/em&gt; and a &lt;em&gt;Phone&lt;/em&gt;. As such, a MultiFunction object should behave as a Phone, a Printer or Copier will behave. That is the object contract between these three interfaces and the class.&lt;/p&gt;

&lt;p&gt;If you review the codes inside &lt;em&gt;TestMultiFunction&lt;/em&gt;, we  did not use the MultiFunction type when the object was created, we used the Type name as specified on the &lt;em&gt;interface&lt;/em&gt; definitions. Let's recap that portion of the code&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
    Printer printer = new MultiFunction();
    Phone phone = new MultiFunction();
    Copier copier = new MultiFunction();
        
    printer.print();
    phone.answerCall();
    copier.copy();
&lt;/pre&gt;


&lt;p&gt;Had we use the code &lt;code class=&quot;codeblock&quot;&gt;&lt;/code&gt;MultiFunction printer = new MultiFunction()&lt;/code&gt; , it would have been fine. The code will still compile and run perfectly. So why didn't we do that? Because I only need a &lt;em&gt;Printer&lt;/em&gt;, I chose a more general type because I am not sure that I will not change the implementation details of the &lt;em&gt;print()&lt;/em&gt; method in the future.&lt;/p&gt;

&lt;p&gt;It can be argued that if I need to change some details of the &lt;em&gt;print()&lt;/em&gt; function, I should just go inside the MultiFunction class and change it, but I would rather not do that for a host of reasons. The most important one being that at some point, some of my codes maybe depending on how I actually implemented the print function inside the MultiFunction class. If I change that, some parts of the application could break.&lt;/p&gt;

&lt;p&gt;On the other hand, using the &lt;em&gt;Printer&lt;/em&gt; interface as a type allows me to achieve loose coupling between the type and its actual implementation. If I need to change some of the details of print() function, I could simply create another class that implements the &lt;em&gt;Printer&lt;/em&gt; type and make that adjustments on the new class. This approach has some level of encapsulation because I am containing the possible (negative) impact of code change.&lt;/p&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
    //If I need to change something on the print function()
    class ColorPrinter implements Printer {
        public void print() {
            ...
        }
    }

    Printer printer = new ColorPrinter();
&lt;/pre&gt;


&lt;p&gt;The above code shows a possible approach if I really need to make adjustments to the print() function in the future.&lt;/p&gt;

&lt;p&gt;All Java objects will have at least one type, but usually it has more than one. The MultiFunction object we have created actually has five. It is a &lt;em&gt;Copier, Printer, Phone, MultiFunction&lt;/em&gt; and a &lt;em&gt;java.lang.Object&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The Copier, Printer and Phone types are easy to see, they were explicitly implemented by MultiFunction, so that's three. The fourth one (MultiFunction) is not very obvious, but whenever you create a new class, you are creating a new Type. Whatever object you will create out of that class will also bear its type. Our object's fifth type is &lt;em&gt;java.lang.Object&lt;/em&gt;. That is because no matter what you do, at some point, your class will extend the &lt;em&gt;Object&lt;/em&gt; class, either directly or indirectly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/object-type.png&quot;&gt;&lt;/p&gt;

&lt;div id=&quot;cap&quot;&gt;Types&lt;/div&gt;


&lt;h3&gt;POLYMORPHISM&lt;/h3&gt;

&lt;p&gt;Did you notice that he &lt;em&gt;MultiFunction&lt;/em&gt; object needed to re-define all the methods it has inherited from the three interfaces? We had to re-define &lt;em&gt;print(), copy, answerCall() and dialNumber()&lt;/em&gt;. Re-defining a method in a subtype is called &lt;em&gt;method overriding&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Overriding a method is done in order for the inheriting class to have a chance to define a unique behavior for the method. For example, the MultiFunction object inherited the &lt;em&gt;copy()&lt;/em&gt; from the &lt;em&gt;Copier&lt;/em&gt; interface. What it effectively means is that MultiFunction is making a promise that because it is now a &lt;em&gt;Copier&lt;/em&gt; object, it will respond to the &lt;em&gt;copy()&lt;/em&gt; message if invoked. The Copier interface did not specify any behavior for the method, it is up to the implementing class (MultiFunction) to provide the behavior. The provision of behavior for an inherited method can be done using method overriding.&lt;/p&gt;

&lt;pre&gt;
    interface Shape {
        void draw();
    }

    class Square implements Shape {
        public void draw() {
            System.out.println(&quot;Drawing a square&quot;);
        }
    }

    class Circle implements Shape {
        public void draw() {
            System.out.println(&quot;Drawing a circle&quot;);
        }
    }

    class TestShape {

        public static void main(String[] args) {
            Shape square = new Square();
            Shape circle = new Circle();
            square.draw();
            circle.draw();
        }
    }

&lt;/pre&gt;




&lt;div id=&quot;cap&quot;&gt;Shape.java&lt;/div&gt;


&lt;p&gt;The Shape program is a very trivial and non-realistic example, but the simplicity should aid our understanding of why we use overriding.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Shape&lt;/em&gt; type could have been written as a class. The &lt;em&gt;Square&lt;/em&gt; and &lt;em&gt;Circle&lt;/em&gt; classes could have &lt;strong&gt;extended&lt;/strong&gt; a Shape class instead of implemented a Shape interface. Why didn't we do that? Here are the reasons&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Shape is not a real object (even in the real world). Shape is a name we give to describe the contour of something, the state of something. It is not &lt;em&gt;something&lt;/em&gt;. Just like animal is the classification we give to cats and dogs. A cat is a real thing, a dog is a real thing, an animal is not. Animal is a &lt;em&gt;type&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;If you think about it hard enough, can &lt;em&gt;Shape&lt;/em&gt; really draw something, will it make sense?&lt;/li&gt;
&lt;li&gt;It makes sense that Circle and Square descend from a common type, after all Circle and Square are, well, shapes.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The &lt;em&gt;draw()&lt;/em&gt; method are both available in Circle and Square, but they have different implementations or behavior (method body). This was possible because we have overriden the draw() method where it makes sense. It makes the &lt;code class=&quot;codeblock&quot;&gt;draw()&lt;/code&gt; method polymorphic, it changes its behavior depending on which object you are calling it against.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;EXCEPTIONS&lt;/h1&gt;


&lt;p&gt;When you start using code libraries written by other people, it is no longer enough to simply know the name of the method and the parameters that you need pass. You also need to know if the methods you will be calling are &lt;em&gt;throwing Exceptions&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;An Exception is an error, an abnormal condition, a disruption of normal program flow.&lt;/p&gt;

&lt;p&gt;Programmer's throw Exceptions from their their codes if they think something has gone awry. As a (responsible and defensive) programmer, you will make sure that your code will be able to respond to non-fatal conditions. Surely you will not allow your program to crash because the user has inputted wrong data. The code must be robust enough to recover from and even rectify abnormal conditions.&lt;/p&gt;

&lt;p&gt;A common routine for applications is opening a file. The workflow is straightforward. User selects a file from a list, your code is supposed craft some sort of display window to display the contents of file, after opening it &amp;mdash; sounds straightforward doesn't it.&lt;/p&gt;

&lt;p&gt;If we tried to code this using the control structures (thus far) available for us, it might look something like&lt;/p&gt;

&lt;pre&gt;
class SampleFileCheck {

    public static void main(String []args)) {

        String filename = askUserToInputFile();
        boolean test_the_file = checkFileExistence();

        if(test_the_file == true) {
            //we know it is safe to open the file
            ...
        }
        else {
            //some codes here to inform
            //the user the file does not exist
            ...
        }   
    }

    static String askuserToInputFile(){
        ...
    }
    
    static boolean checkFileExistence() {
        ...    
    }

}
&lt;/pre&gt;


&lt;p&gt;From this trivial example I hope it is clear why we need to bother making our code robust. We need to anticipate error conditions because we cannot predict the kind of environment our codes will be subjected to.&lt;/p&gt;

&lt;p&gt;End users are prone to commit errors and misspell things. Network connections go down, databases get corrupted, the list can go on. These are some of the many reasons why we need to bother with abnormal conditions.&lt;/p&gt;

&lt;p&gt;It begs the question now &quot;How can we know if a method can throw Exceptions?&quot; The unfortunate answer is &quot;Read the API documentation&quot;. The documentation of Java is readily available in a variety of format, so there is no excuse not to read it.&lt;/p&gt;

&lt;p&gt;If you need only to peek quickly at the method signatures of specific classes, the &lt;em&gt;javap&lt;/em&gt; utility allows you to print a summary of class methods. You can do that from the command line. Try it now &amp;mdash; &lt;code class=&quot;codeblock&quot;&gt;javap java.lang.String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This command will output to the console all the methods and constructors that are found inside java.lang.String. Remember that you need to use the fully qualified name of the class.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;TRY-CATCH&lt;/h2&gt;

&lt;p&gt;Going back to our pseudo code sample of reading a file, if we were to code this in Java, it would look like this&lt;/p&gt;

&lt;pre&gt;
    String filename = &quot;something.txt&quot;;
        
    try {
        FileReader reader = new FileReader(filename);
    }
    catch(FileNotFoundException fe) {
            
    }
&lt;/pre&gt;


&lt;p&gt;Notice that there is no &lt;em&gt;if-else&lt;/em&gt; block as written in the pseudo code? A &lt;em&gt;try-catch&lt;/em&gt; mechanism was used for routing program flow instead.&lt;/p&gt;

&lt;p&gt;The try-catch block is Java's prescribed way of handling codes that may encounter abnormal conditions. It is somewhat similar to the if-else conditions in so far as it branches the program flow depending on whether there is an Exception encountered or not.&lt;/p&gt;

&lt;p&gt;to recap&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q:&lt;/strong&gt; What should I write inside the try block&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; statements that may throw Exceptions. There is no point writing a try block around a statements that do not declare Exceptions&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; What should I put inside the catch block&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; statements that you need in order to cope with the abnormal conditions. It could be as simple as logging the error. Sometimes you may need to write code in order to recover from the error.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; How do I know which Exceptions to catch&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Read the API of the method you intend to call. In our FileReader example, I actually ran the command &lt;code class=&quot;codeblock&quot;&gt;$ javap java.io.FileReader&lt;/code&gt; from a console, that's how I knew that the constructor of the &lt;em&gt;FileReader&lt;/em&gt; class throws the FileNotFoundException&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; What if I need to call another method, and it throws a different Exception&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Well, just add another &lt;em&gt;catch&lt;/em&gt; block to your try-catch mechanism. You can have multiple catch blocks anyway.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Do I always need to use the try-block&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A:&lt;/strong&gt; No, if the method you are invoking is not throwing any Exception, then there is no need to try-catch it. See the answer above.&lt;/li&gt;
&lt;/ul&gt;


&lt;hr /&gt;

&lt;h2&gt;TRY-CATCH-FINALLY&lt;/h2&gt;

&lt;p&gt;The finally block has a special purpose. Whatever you write inside the finally block gets executed, no matter if an Exception was raised or not.  This behaviour makes it ideal for writing clean up codes, such as closing database connections or closing file connections&lt;/p&gt;

&lt;pre&gt;
    try {
        Statement 1;
        Statement 2;
        Statement 3;
        Statement 4;
    }

    catch(Exception e) {
        Statement 5;
        Statement 6;
    }

    finally{
        Statement 7;
        Statement 8;
    }
&lt;/pre&gt;


&lt;p&gt;Let's do some scenario analysis&lt;/p&gt;

&lt;h3&gt;IF EVERYTHING WENT OKAY&lt;/h3&gt;

&lt;p&gt;Every statement inside the try block will be executed, then every statement inside the finally block will be executed as well. None of the statements within the catch block will be executed.&lt;/p&gt;

&lt;h3&gt;SOMETHING WENT WRONG, STATEMENT 2 WENT BONKERS&lt;/h3&gt;

&lt;p&gt;In this case, statement Nos. 3 &amp;amp; 4 will be skipped. Program flow will be transferred immediately to the catch block. All the statements inside the catch block will be executed. Then all the statements in the finally block will be executed&lt;/p&gt;

&lt;p&gt;As a matter of flow of control, you cannot circumvent the finally block, it will be executed, no matter what &amp;mdash; actually, that's not true, there is a statement that can force the &lt;em&gt;finally&lt;/em&gt; clause to be skipped, that is &lt;code class=&quot;codeblock&quot;&gt;System.exit(1)&lt;/code&gt;. That code is guaranteed to halt anything, but you know what I mean, you really wouldn't use this statement irresponsibly now, would you?&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;THROWS CLAUSE&lt;/h2&gt;

&lt;p&gt;When you invoke a method and it throws an &lt;em&gt;Exception&lt;/em&gt;, you can somewhat ignore it.How do you do that? The answer can be a bit long-winded, but bear with me.&lt;/p&gt;

&lt;p&gt;Remember our code for reading a file? We had to use a library from &lt;em&gt;java.io&lt;/em&gt;, the FileReader class. The FileReader is a standard library for Java. If you read the API doc for that class, you will find something like this&lt;/p&gt;

&lt;pre&gt;
public FileReader {

    public FileReader(String filename) throws FileNotFoundException {

    }
}
&lt;/pre&gt;


&lt;p&gt;There is &lt;em&gt;throws&lt;/em&gt; clause in the constructor of the FileReader. What does it mean for us? It means that we need to take some caution using this class. We need to take extra steps even at the point of instantiation. The &lt;em&gt;throws&lt;/em&gt; clause is warning us that it can potentially throw an error and it needs to be handled appropriately.&lt;/p&gt;

&lt;p&gt;There are two ways we can call methods that have &lt;em&gt;throws&lt;/em&gt; clause. We have already done the first one a while back (the try-catch-finally). The other way to handle such methods is to kick the Exception upwards &amp;mdash; let me explain that by starting with a code example.&lt;/p&gt;

&lt;pre&gt;
import java.io.FileReader;
import java.io.FileNotFoundException;

class FileSample {
    
    public static void main(String[] args) throws FileNotFoundException {
        
        String filename = &quot;something.txt&quot;;
        FileReader reader = new FileReader(filename);
        
    }
}
&lt;/pre&gt;


&lt;p&gt;In the code construction above, we did not enclose the &lt;em&gt;FileReader&lt;/em&gt; constructor inside a &lt;em&gt;try-catch&lt;/em&gt; block. We declared a throws clause as part of the &lt;em&gt;main()&lt;/em&gt; method.&lt;/p&gt;

&lt;p&gt;If something does happen inside the body of the &lt;em&gt;main()&lt;/em&gt; method, say the FileReader constructor encounters an error because the file wasn't there, I will not handle inside the &lt;em&gt;main()&lt;/em&gt; method.&lt;/p&gt;

&lt;p&gt;The thrown Exception will first look if there is any &lt;em&gt;try-catch&lt;/em&gt; block where the error can be handled. It won't find any, because we did not write one. The Exception will then look at the signature of the method where the Exception has happened &amp;mdash; in this case, inside &lt;em&gt;main()&lt;/em&gt;. The error will be passed to a higher level in the call stack (who ever called method &lt;em&gt;main&lt;/em&gt;). Of course, the one who will call the main() method is already the JVM, so in case something abnormal does happen to our code while executing the FileReader constructor, the JVM will simply halt and throw us a bunch error printouts.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;BUBBLE THE EXCEPTION UP THE CALL STACK&lt;/h2&gt;

&lt;p&gt;Let's work with another example. This is not different from the previous example, just more elaborate. In this construction, the main method calls &lt;em&gt;doo&lt;/em&gt; which in turn calls &lt;em&gt;foo&lt;/em&gt; which in turn calls &lt;em&gt;goo&lt;/em&gt;. Method &lt;em&gt;goo&lt;/em&gt; throws the &lt;em&gt;FileNotFoundExcpetion&lt;/em&gt;, so does &lt;em&gt;foo&lt;/em&gt; and so does &lt;em&gt;doo&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;
import java.io.FileNotFoundException;

class ThrowSample {

    public static void main (String [] args) {
        
        ThrowSample ts = new ThrowSample();
        
        try {
            ts.doo();
        }
        catch(FileNotFoundException fe) {
            //error handling
            //code here
        }
    }

    void doo() throws FileNotFoundException {
        foo();
    }

    void foo() throws FileNotFoundException{
        goo();
    }

    void goo() throws FileNotFoundException {
        //Open a file here
    }
}
&lt;/pre&gt;


&lt;p&gt;Notice that inside &lt;em&gt;goo&lt;/em&gt;, there is no try-catch block? That should not be a surprise anymore. We know the reason why we don't have to try-catch inside &lt;em&gt;goo&lt;/em&gt;, that is because, in the method signature, we said that it &lt;em&gt;throws FileNoutFoundException&lt;/em&gt;. If anything happens inside method &lt;em&gt;goo&lt;/em&gt;, we will simply throw upwards to whoever called method &lt;em&gt;goo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/exception-bubble.png&quot;&gt;&lt;/p&gt;

&lt;div id=&quot;cap&quot;&gt;How Exceptions are propagated&lt;/div&gt;


&lt;p&gt;Method foo invoked &lt;em&gt;goo&lt;/em&gt;, &lt;em&gt;foo&lt;/em&gt; also did not use a try-catch block to handle the FileNotFoundException, instead, it also passed the buck upwards.&lt;/p&gt;

&lt;p&gt;The buck stopped at method &lt;em&gt;main&lt;/em&gt;, we did not declare a throws clause on the signature of &lt;em&gt;main&lt;/em&gt; and hence, we are obliged to handle the Exception using a &lt;em&gt;try-catch&lt;/em&gt; block.&lt;/p&gt;

&lt;p&gt;Whenever you are using a method, always check the signature. If the signature declares that it is throwing Exceptions, you need to handle that exception your code either by re-throwing it up the call stack, or by enclosing it in a try-catch block. You do this for &lt;strong&gt;CHECKED EXCEPTIONS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;There are errors and &lt;em&gt;Exceptions&lt;/em&gt; that may still be thrown during runtime, but you will not find them on the declaration of method signatures. These are called &lt;strong&gt;UNCHECKED EXCEPTIONS&lt;/strong&gt;, for example, say you tried to divide some integer value with zero, that will result to an &lt;em&gt;ArithmeticException&lt;/em&gt; &amp;mdash; but you don't guard against arithmetic exceptions during compile time though.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;WRITING YOUR OWN EXCEPTIONS&lt;/h2&gt;

&lt;p&gt;You can write your own Exceptions if you want to, For whatever reason you may have. Some people write Exceptions to closely model the business domain they are working on, for example, when balance of a SavingsAccount object goes down below a set threshold, some programmers might throw an Exception like &quot;InsufficientBalanceException&quot;.&lt;/p&gt;

&lt;p&gt;To create your own Exception, the simplest way is to extend &lt;em&gt;java.lang.Exception&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;
class A extends Exception  {
    
    public String getMessage() {
        return &quot;You got an error on ...&quot;;
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Custom Exception&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Class A&lt;/em&gt; is now a bonafide Exception object. You can &lt;em&gt;throw, try and catch&lt;/em&gt; type A objects just as would throw, try and catch any other built-in Exception objects in Java.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;codeblock&quot;&gt;getMessage()&lt;/code&gt; method was overridden so we can provide a friendly error message when the Exception is triggered. Whatever you write inside the body of &lt;em&gt;getMessage()&lt;/em&gt; will be spewed to the screen, in case the Exception is triggered.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;REMEMBER THE FOLLOWING&lt;/h2&gt;

&lt;p&gt;When calling java method that have been coded by other people (or even coded by you), you need to be aware whether or not they are throwing Exceptions.&lt;/p&gt;

&lt;p&gt;If the methods are declared to throw Exceptions, you need to choose how you will handle it. You can a) handle it using try-catch-finally or you can b) let other methods bother with the Exception by simply putting a &lt;em&gt;throws clause&lt;/em&gt; on your own methods.&lt;/p&gt;

&lt;p&gt;If you do decide to handle the Exception using try-catch-finally mechanism, remember that you can declare as many &lt;em&gt;catch&lt;/em&gt; blocks as you need.&lt;/p&gt;

&lt;p&gt;If you do write a &lt;em&gt;finally&lt;/em&gt; clause, remember that all the codes inside that block will get executed no matter what.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;METHODS&lt;/h1&gt;


&lt;p&gt;First order of business is start calling functions as &lt;em&gt;methods&lt;/em&gt;. This will be the last time we will call them functions. They are called methods because they are not simple functions, they are behaviours. They are bound to an object context and they can have privileged access to some data, unlike the simplistic function &amp;mdash; sounds like semantics, I know, but just start using the term method instead of function.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;BASICS&lt;/h2&gt;

&lt;p&gt;You define methods they way you define regular functions. The difference is that, in Java, method are written always inside a class structure. There are no stand alone methods. Methods cannot exist without the context of either an object or a class.&lt;/p&gt;

&lt;pre&gt;

void main() {} // this is not allowed

class SomeClass {
    void main(){} // this is allowed
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Where to define a method&lt;/div&gt;


&lt;p&gt;You can define as many methods as you like inside a class, just fire away. The coherence and granularity of your methods is a matter of &lt;em&gt;analysis &amp;amp; design&lt;/em&gt; &amp;mdash; that is outside the scope of this material.&lt;/p&gt;

&lt;pre&gt;
class SomeClass {
    void one(){}
    void two(){}
    void three(){} 
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;A class with many methods&lt;/div&gt;


&lt;p&gt;It is important to point out that the order of definition does not affect the order of execution of these methods. These are not statements where the order of definition dictates the order of execution. The methods can be invoked in any order during runtime.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;METHOD NAMING&lt;/h3&gt;

&lt;p&gt;You will decide the name of the method, their names follow the same rules as names of other &lt;em&gt;identifiers&lt;/em&gt;. You follow the same rules when naming a method as you would name a variable &amp;mdash; not a reserved word, no special characters, can't start with a number. These are the hard rules.&lt;/p&gt;

&lt;p&gt;There are soft rules. They are  called &lt;em&gt;soft rules&lt;/em&gt; because they are not enforced by the compiler &amp;mdash; they should have been &amp;mdash; but they are important to remember nevertheless. These soft rules are actually referred to as &lt;em&gt;best practices&lt;/em&gt;. There is no shortage of best practices in Java, just Google it up and you will see what I mean. Anyway, I have just one more to add to our rules. Make the method name descriptive of what it is actually doing.&lt;/p&gt;

&lt;h3&gt;RETURN TYPES&lt;/h3&gt;

&lt;p&gt;A method can return any valid type in Java. They can return any of eight the primitive types and any valid reference type. It can even return nothing if you choose to.&lt;/p&gt;

&lt;pre&gt;
class Example {
    public static void main() {
        int res = add(2,3)
    }
    
    static int add(int i, int j) {
        return i + j;
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Method sample&lt;/div&gt;


&lt;p&gt;In our example code the method &lt;em&gt;add()&lt;/em&gt; is defined as returning an int. Don't get distracted by the &lt;em&gt;static&lt;/em&gt; keyword right now, I had to put that in so that the code will properly compile and run, but you are not ready yet to deal with static. We will come around to &lt;em&gt;static&lt;/em&gt; in a little while. Our &lt;em&gt;add&lt;/em&gt; method is defined to return an &lt;em&gt;int&lt;/em&gt; type, that is why there is a &lt;em&gt;return&lt;/em&gt;  statement inside it. Specifically, the &lt;em&gt;return&lt;/em&gt; statement is the last executable line within the method body. It has to be. Any other statement right after &lt;em&gt;return&lt;/em&gt; will be unreachable.&lt;/p&gt;

&lt;p&gt;This is an example of a &lt;strong&gt;productive&lt;/strong&gt; method, one that actually returns something or &lt;em&gt;produces&lt;/em&gt; something.&lt;/p&gt;

&lt;p&gt;There are methods that don't (have to) return anything. Non-productive methods are constructed to return the &lt;em&gt;void&lt;/em&gt; type &amp;mdash; yes void is a type. It means to return &lt;em&gt;nothing&lt;/em&gt;. There are lots of debate on this one but you can look it up yourself in the Java Lang Spec on your own, when you have more programming muscles in Java. What is important to remember now is the mechanics of how to craft a &lt;em&gt;void method&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;
class Example {
    public static void main() {
        talkBack(&quot;Hello there&quot;);
    }
    
    static void talkBack(String arg) {
        System.out.println(&quot;arg&quot;);
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;A void method&lt;/div&gt;


&lt;p&gt;When a method is defined as &lt;em&gt;void&lt;/em&gt; you don't need to write a &lt;em&gt;return&lt;/em&gt; statement. In fact, you cannot lest you will have a compile time error.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;WHAT TO PUT INSIDE METHODS&lt;/h2&gt;

&lt;p&gt;To put it simply, methods are the workhorses of your program. Objects and Classes maybe glorified not only the Java language but in others as well, but when the rubber hits the road, all the side effects and compute engines are written inside the method block.&lt;/p&gt;

&lt;p&gt;The two things you will write inside methods are &lt;em&gt;statements&lt;/em&gt; and &lt;em&gt;control structures&lt;/em&gt; &amp;mdash; the foundations of imperative programming languages. Obviously I cannot tell you right now which statements and structures to exactly to put in your methods. You need to figure that our for yourself. It is upon you, the programmer, to craft the statements and structures that will achieve your goals. I can, however, show you an example of how to write some methods.&lt;/p&gt;

&lt;pre&gt;
class Table {
  
  public static void main(String[] args) {
    System.out.println(generateTable(5));
  }
  
  static String generateTable(int size) {
    String returnVal = &quot;&quot;;
    for (int i = 1; i &lt;= size ; i++ ) {
      for (int j = 1; j &lt;= size; j++ ) {
        returnVal += (i * j) + &quot;\t&quot;;
      }
      returnVal += &quot;\n&quot;;
    }
    return returnVal;
  }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Multiplication table&lt;/div&gt;


&lt;p&gt;At this point, you should have enough moxy to walk through the sample code above. It generates the multiplication table.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;generateTable&lt;/em&gt; method takes an integer argument because I would the size of the table to be changeable or parameterised. I did not want to method to produce the side effect itself, that is why the printing is done on the &lt;em&gt;main()&lt;/em&gt; method. I only intended for the method to return a &lt;em&gt;String&lt;/em&gt; representation of the generated table, hence the &lt;em&gt;String return type&lt;/em&gt;. The &lt;em&gt;\t&lt;/em&gt; is just to separate the values with a tab character.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;WHAT STATIC MEANS&lt;/h1&gt;


&lt;p&gt;During the &lt;strong&gt;OOP&lt;/strong&gt; discussion, we talked about &lt;em&gt;classes &amp;amp; objects&lt;/em&gt;. We said that an object is an instance of class. We used the analogy of blueprints and houses &amp;mdash; a class is to a blue print as a house is to an object.&lt;/p&gt;

&lt;p&gt;The house and blueprint analogy was good enough to visualise the structural relationship between objects and classes. Now we must   stretch our understanding of &lt;em&gt;objects&lt;/em&gt; and &lt;em&gt;classes&lt;/em&gt; to include how they affect storage.&lt;/p&gt;

&lt;p&gt;First, some definition. When we say &lt;em&gt;member&lt;/em&gt;, it can mean either a variable or a method. By the way, all variables and methods are members of something. Remember that you cannot define anything outside a class. So when I say &lt;em&gt;a variable&lt;/em&gt; I mean a member variable &amp;mdash; same goes for the method. I will not make any distinction between a simple variable and a member variable, they both mean the same in Java. Alright, that is out of the way now.&lt;/p&gt;

&lt;p&gt;There are two kinds of members. A &lt;em&gt;instance member&lt;/em&gt; means it belongs to an &lt;em&gt;object&lt;/em&gt; (an instance of a class) and a &lt;em&gt;class member&lt;/em&gt; which means it belong to the class and not the object. Why is this distinction important? Because it affects the way you invoke methods and it affects the way variables are kept.&lt;/p&gt;

&lt;p&gt;An object is enclosed thing, it's encapsulated &amp;mdash; variables, methods and all. If you want an object to do something, you first must create it and then call one of its method. An instance method is always invoked from the context of a created object.&lt;/p&gt;

&lt;pre&gt;
class Sample {
    public static void main(String []args) {
        bark();
    }
}

class Dog {
    void bark() {
        System.out.println(&quot;Bow wow!&quot;);
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Dog Sample&lt;/div&gt;


&lt;p&gt;This code won't work because when &lt;em&gt;main&lt;/em&gt; called &lt;em&gt;bark&lt;/em&gt;, it doesn't know where the method &lt;em&gt;bark&lt;/em&gt; is. You have to tell it where to find that method.&lt;/p&gt;

&lt;pre&gt;
class Sample {
    public static void main(String []args) {
        Dog objdog = new Dog();
        objdog.bark();
    }
}

class Dog {
    void bark() {
        System.out.println(&quot;Bow wow!&quot;);
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Dog Sample&lt;/div&gt;


&lt;p&gt;This example works because before invoking &lt;em&gt;bark&lt;/em&gt;, we first created an instance of a &lt;em&gt;Dog&lt;/em&gt;, saved the object in &lt;em&gt;objdog&lt;/em&gt; then invoked &lt;em&gt;bark&lt;/em&gt;. Our main method actually does know who owns the &lt;em&gt;bark&lt;/em&gt; behaviour.&lt;/p&gt;

&lt;p&gt;The method &lt;em&gt;bark&lt;/em&gt; is owned by an instance of a &lt;em&gt;Dog&lt;/em&gt; class (you need to create it, which means you need to call &lt;em&gt;bark&lt;/em&gt; from within the context of &lt;em&gt;Dog&lt;/em&gt; instance and not a &lt;em&gt;Dog&lt;/em&gt; class.&lt;/p&gt;

&lt;p&gt;How can we tell if a method is belongs to an instance and not its class then? Easy. By default, all members automatically belong to an object and not its class. More specifically all members that DOES NOT HAVE THE &lt;em&gt;static&lt;/em&gt; keyword before it belongs to an object &amp;mdash; not its class.&lt;/p&gt;

&lt;p&gt;If we wanted to the &lt;em&gt;bark&lt;/em&gt; method to belong to its class and not its instance, we would put the &lt;em&gt;static&lt;/em&gt; keyword before the method, like this.&lt;/p&gt;

&lt;pre&gt;
class Sample {
    public static void main(String []args) {
        Dog.bark();
    }
}

class Dog {
    static void bark() {
        System.out.println(&quot;Bow wow!&quot;);
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Dog Sample, static version&lt;/div&gt;


&lt;p&gt;See the difference. You didn't have to create an instance of the &lt;em&gt;Dog&lt;/em&gt; before you invoked &lt;em&gt;bark&lt;/em&gt;. You just called it flat out. Now why you would choose a member to either static or non-static is a matter of design and analysis. We are not going to discuss that here. That is an entirely different (and interesting) discussion on its own.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;STATIC VARIABLES VS INSTANCE VARIABLES&lt;/h2&gt;

&lt;p&gt;An &lt;em&gt;instance variable&lt;/em&gt; is owned by the object. Each instance have their own copies, protected and encapsulated copies of those variables. Whatever you do to a variable on one instance does not affect the copies of the variables on other instances.&lt;/p&gt;

&lt;pre&gt;
class World {
    public static void main(String args[]){
        Person p1 = new Person(&quot;John&quot;);
        Person p2 = new Person(&quot;Jane&quot;);
        
        System.out.println(p1.getName());   
        System.out.println(p2.getName());
        
        p1.setName(&quot;Guido&quot;);

        System.out.println(p1.getName());   
        System.out.println(p2.getName());
    }
}

class Person{
    String name;
    Person(String arg) {
        name = arg;
    }
    void setName(String arg){name = arg;}
    String getName() {return name;}
}
&lt;/pre&gt;


&lt;p&gt;This logic sits well with conventional wisdom. I created two &lt;em&gt;Person&lt;/em&gt; objects p1 and p2, named &quot;John&quot; and &quot;Jane&quot; respectively. I changed the name of p1 to &quot;Guido&quot;. Only p1 should be affected by the change and not p2. If instance members were not encapsulated and if they did not own copies of the &lt;em&gt;name&lt;/em&gt; variable, our results would have been weird.&lt;/p&gt;

&lt;pre&gt;
class World {
    public static void main(String args[]){
        Person p1 = new Person(&quot;John&quot;);
        Person p2 = new Person(&quot;Jane&quot;);
        
        System.out.println(p1.getName());   
        System.out.println(p2.getName());
        
        p1.setName(&quot;Guido&quot;);

        System.out.println(p1.getName());   
        System.out.println(p2.getName());
    }
}

class Person{
    static String name; // this will make it weird
    Person(String arg) {
        name = arg;
    }
    void setName(String arg){name = arg;}
    String getName() {return name;}
}
&lt;/pre&gt;


&lt;p&gt;Changing the storage specification of the &lt;em&gt;name&lt;/em&gt; member from instance to class (static) changes the behaviour. Now all instances of the &lt;em&gt;Person&lt;/em&gt; class will share only one copy of the &lt;em&gt;name&lt;/em&gt; variable. This means whatever change and wherever you make that change from, it will affect all &lt;em&gt;Person&lt;/em&gt; objects. Run it for yourself and see, both &lt;em&gt;p1&lt;/em&gt; and &lt;em&gt;p2&lt;/em&gt; will print the name &quot;Guido&quot;. This happens because &lt;em&gt;name&lt;/em&gt; is now a shared variable across all instances of the &lt;em&gt;Person&lt;/em&gt; class. A static member is not an exclusive copy. Objects do not own copies of static members.&lt;/p&gt;

&lt;p&gt;Think about it this way. You can have many instances of a class, that means you can have x-number of objects floating around created from the same class. Each object is autonomous and independent from one another. So it makes that each object will really have their own unique copies of their data. When you put that data inside the class, there is only one class, hence any of its instances can see the data and can change the data. The data is shared.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REMEMBER&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A static member, either a variable or method are stored on the class, not the its instance&lt;/li&gt;
&lt;li&gt;A static member will always have the &lt;em&gt;static&lt;/em&gt; keyword before it, otherwise it is non-static&lt;/li&gt;
&lt;li&gt;A non-static member cannot be accessed directly by a static method. You need to create an object first, then access the member via the reference variable&lt;/li&gt;
&lt;li&gt;A static member on the other hand, can be accessed by a non-static method. It's not fair right, but best remember this&lt;/li&gt;
&lt;/ol&gt;


&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;ACCESS CONTROL AND PACKAGES&lt;/h1&gt;


&lt;p&gt;Access implies that there is a boundary or a wall that blocks us from entering. It implies enclosure.&lt;/p&gt;

&lt;p&gt;In a programming language they are not referred to as enclosures. They are called &lt;em&gt;scope&lt;/em&gt;. Java constructs have scopes. When you define a variable inside a method, you can only use that variable within that method. When a variable is defined within a class, all methods in that class can use that variable &amp;mdash; it is also possible for other classes to use that variable, if the programmer will allow it. Here begins our discussion on &lt;em&gt;accessibility&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Java organizes certain things according to hierarchy. You may have been increasingly aware of this hierarchy by now. Statements and variables make up methods. Methods and variables make up a class. Classes make up a &lt;em&gt;package&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A package in Java are like folders in your PC. Folders allow you to organize things, segregate stuff and tuck them away easily and tidily for easy retrieval. Folders allow you to give the same name to two different files as long as they are on different folders. Using this analogy, &lt;em&gt;Java packages&lt;/em&gt; are folders and &lt;em&gt;Java classes&lt;/em&gt; are files. Classes belong to a package just like a file belong to a folder.&lt;/p&gt;

&lt;p&gt;All the code examples we have used thus far do not specify a particular package. We have never given Java any instruction that the classes we wrote should be placed in a specific &quot;folder&quot;. Java however, worked in the background and placed our codes in a default &lt;em&gt;no-name&lt;/em&gt; package. Consider the next code example.&lt;/p&gt;

&lt;pre&gt;
import java.util.Date;

class DateSample {
    public static void main(String []args) {
        Date date = new Date(); 
        System.out.println(date);
    }    
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;DateSample.java&lt;/div&gt;


&lt;p&gt;Compile the example source and list the contents of the directory. You will find a file named DateSample.class. There is nothing unusual there. If you run the sample code you are running it from context of the &lt;em&gt;no-name&lt;/em&gt; package, which is the current working directory.&lt;/p&gt;

&lt;p&gt;Don't sweat about this &lt;em&gt;no-name&lt;/em&gt; package. Just remember that if you do not define your package explicitly, Java will define it for you &amp;mdash; implicitly.&lt;/p&gt;

&lt;p&gt;Let's write another sample.&lt;/p&gt;

&lt;pre&gt;
package com.tedhagos;

import static java.lang.System.out;

public class PackageSample {
    
    public static void main (String [] args) {
        out.println(&quot;Hello again\n&quot;);
    }

}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;PackageSample.java&lt;/div&gt;


&lt;p&gt;There is something new in this code. There is a &lt;em&gt;package directive&lt;/em&gt;.This directive must be written as the first executable statement in a source file, that is a compilation requirement. The only things that you can write before it are comments.&lt;/p&gt;

&lt;p&gt;The package name is programmer defined. You are responsible for choosing the name. In the example code, I used &lt;em&gt;com.tedhagos&lt;/em&gt;. I used the &lt;em&gt;reverse-DNS notation&lt;/em&gt;. You are not compelled to follow the convention but I need to tell you that the reverse-dns notation is widely used, not only in Java projects but in others as well. Best to learn to it.&lt;/p&gt;

&lt;p&gt;Java programs with package directive are compiled a little bit differently. You need to add some flags to the compilation command &amp;mdash; &lt;code class=&quot;codeblock&quot;&gt;javac -d . PackageSample.java&lt;/code&gt;. The &lt;em&gt;-d&lt;/em&gt; in javac means we would like to specify where to place the generated class files.&lt;/p&gt;

&lt;p&gt;The dot character after the &lt;em&gt;-d&lt;/em&gt; flag means that to generate the package (folder) structure relative to the current working directory. If you inspect the output directory after executing the javac command, you will see something like the pic below&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/packagesample.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;You cannot run this sample code using &lt;code class=&quot;codeblock&quot;&gt;java PackageSample&lt;/code&gt;. That will fail because the &lt;em&gt;PackageSample&lt;/em&gt; class is no longer within the &lt;em&gt;no-name&lt;/em&gt; default package.&lt;/p&gt;

&lt;p&gt;We explicitly told the Java compiler to put to things inside the  &lt;em&gt;com.tedhagos&lt;/em&gt; package (folder). The fully qualified name of our program is now &lt;em&gt;com.tedhagos.PackSample&lt;/em&gt;, so the way to run it is &lt;code class=&quot;codeblock&quot;&gt;java com.tedhagos.PackageSample&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;ACCESS MODIFIERS&lt;/h2&gt;

&lt;p&gt;Access modifiers are reserved words that you put before variables, methods or classes in order to control their visibility or accessibility. There are four of them, &lt;em&gt;public, protected, package and private&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;When something is &lt;em&gt;public&lt;/em&gt;, it can be accessed from anywhere. It's free for all. A public member can be accessed from 1) within the same class 2) another class 3) a class from another package &amp;mdash; in short, everywhere.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/access.png&quot;/&gt;&lt;/p&gt;

&lt;div id=&quot;cap&quot;&gt;Accessiblity&lt;/div&gt;


&lt;p&gt;A top-level class declared as public can be referenced or used both within its package or outside its package. A public class usually will be defined with a public constructor.&lt;/p&gt;

&lt;pre&gt;
public class Foo {
    
    public String name = &quot;&quot;;

    public String getName() {
        return name;    
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;A public class, ctor and variable&lt;/div&gt;


&lt;p&gt;The extreme opposite of &lt;em&gt;public&lt;/em&gt; is &lt;em&gt;private&lt;/em&gt;, it is the most restrictive of all modifiers. A private member can only be used from within the class where it was defined. It is not reachable outside that class &amp;mdash; you also need to remember that when a member is &lt;em&gt;private&lt;/em&gt; you cannot inherit it, it is hidden even from subclasses.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;package and protected&lt;/em&gt; are somewhere in the middle. A member having package accessibility can only be used by classes within the same package. It is unreachable outside the package. Unlike the other modifiers, you don't explicitly prefix a member   with the &lt;em&gt;package&lt;/em&gt; keyword because it is the default accessibility for all members. When a member is defined without any access modifier, its accessibility is &lt;em&gt;package&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;protected&lt;/em&gt; modifier is somewhat similar to package access. Members with this accessibility are also reachable only within the same package with one notable exception. They can also be reached by other classes outside the package provided that that class is a child class.&lt;/p&gt;

&lt;pre&gt;
package com.tedhagos.one;

public class GoodSingleton {

    protected static int instanceCounter = 0;
    protected GoodSingleton() {
        instanceCounter++;
    }

    public static GoodSingleton getInstance() {
        
        GoodSingleton retval = null;

        if (instanceCounter &lt;= 0) {
            retval = new GoodSingleton();
        }
        else {
            System.out.println(&quot;Error in creation&quot;);
        }
        return retval;
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;GoodSingleton.java&lt;/div&gt;


&lt;p&gt;The code is an example of how to implement a Singleton Design pattern in Java. A Singleton pattern ensures that there is only one or a limited number of times you can instantiate a Java class. That is the reason why the constructor was not defined as public.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SUMMARY&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Declaring everything as public will let you avoid development nuisance because everything is accessible. There won't be any compilation errors due to a variable or method that is inaccessible because everything is visible and reachable. It also does not show programming finesse. Declaring everything as private will not let you go very far either because it is too restrictive. Knowing when to use which modifier is a skill that you will acquire overtime, by reading and studying code of other programmers and your own.&lt;/p&gt;

&lt;p&gt;To recap. Here is the list access modifiers ranked in descending order, from the least restrictive to the most restrictive.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;public - least restrictive, accessible from anywhere&lt;/li&gt;
&lt;li&gt;protected - can be accessed from classes within the same package. Can also be accessed by classes outside the package but the accessing classes needs to be a subclass&lt;/li&gt;
&lt;li&gt;package or default - can be accessed only by classes within the same package&lt;/li&gt;
&lt;li&gt;private - most restrictive. Can only be accessed from within the class where it is defined&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;h3&gt;THE SPECIAL CASE OF A PRIVATE CTOR&lt;/h3&gt;

&lt;p&gt;Constructors are defined as public most of the time. It makes sense to define them that way because it means wherever the class is reachable, so is the constructor. The accessibility of the constructor is still limited by the accessibility of the containing class. A public constructor does not necessarily make the containing class public.&lt;/p&gt;

&lt;p&gt;On some rare occasions, a constructor is defined as &lt;em&gt;private&lt;/em&gt;. This effectively prevents anybody from creating an instance of the class and implicitly, it makes the class a &lt;em&gt;final&lt;/em&gt; one because it also cannot be extended anymore.&lt;/p&gt;

&lt;p&gt;One of the prevailing reasoning for making a private constructor is to achieve a &lt;a href=&quot;http://en.wikipedia.org/wiki/Singleton_pattern&quot;&gt;Singleton&lt;/a&gt; effect. By preventing &lt;em&gt;new&lt;/em&gt; keyword from creating objects, you need to devise a way to create objects other than calling the constructor. Presumably this other way of creating the object involves a static method call that allows the programmer to &lt;em&gt;count&lt;/em&gt; the number of instances of the object. The Singleton pattern has been popularised by GoF (Gang of Four)  in their book &lt;a href=&quot;http://en.wikipedia.org/wiki/Design_Patterns&quot;&gt;Design Patterns, Elements of Reusable code.&lt;/a&gt;&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;METHOD OVERLOADING&lt;/h1&gt;


&lt;p&gt;Overloading means you can define a method more than once. For example, you can write the &lt;em&gt;add()&lt;/em&gt; method four times within the same class. One to add integers, another for double another for long etc. You do need to make the methods distinguishable from one another &amp;mdash; but how can we distinguish one from another if they are identical? To answer that, we need an example&lt;/p&gt;

&lt;pre&gt;
int add(int i, int j){return i + j;}
long add(long i, long j){return i + j;}
float add(float i, float j){return i + j;}
double add(double i, double j){return i + j;}
&lt;/pre&gt;


&lt;p&gt;The four methods above have exactly the same name, &lt;em&gt;add&lt;/em&gt; but the method signatures are not identical. The return type, the name of the method and the parameters it accepts constitutes the &lt;em&gt;method signature&lt;/em&gt;. In the sample code, only their names are identical. This is how you provide distinction for overloaded methods. This is how to make the Java methods &lt;em&gt;parametrically polymorphic&lt;/em&gt;. Note that this is different from polymorphism where inheritance is involved.&lt;/p&gt;

&lt;h2&gt;EXAMPLE OF A BAD OVERLOAD&lt;/h2&gt;

&lt;pre class=&quot;codeblock&quot;&gt;
void addTwoNumbers(float x,float y) {}
void addTwoNumbers(float a,float b) {}
&lt;/pre&gt;


&lt;p&gt;The two methods above are identical. Changing the names of parameter does not make them distinct. Had you changed the type of the parameters, that would have been a valid overload.&lt;/p&gt;

&lt;p&gt;You can use overloading to deal with situations where the method needs to respond to a variety of inputs, e.g. one method will deal with floats and the other will deal with integers&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;OVERRIDING, BEING POLYMORPHIC&lt;/h1&gt;


&lt;p&gt;The mechanics of &lt;em&gt;overriding&lt;/em&gt; is easy enough. We can simply study a code sample and I will point out what is considered valid and not valid in code. Somehow I don't think the code mechanics is the reason why polymorphism is poorly understood. This is a matter of the &lt;em&gt;why&lt;/em&gt; and not the &lt;em&gt;how&lt;/em&gt;. But anyway, lets study a code sample.&lt;/p&gt;

&lt;pre&gt;
class Employee {
    void work() {
        System.out.println(&quot;I am working&quot;);
    }
}
class Programmer extends Employee {
    void work() {
        System.out.println(&quot;I am programming&quot;);
    }
}
class TestEmployee {
    public static void main(String[] args) {
        Employee e = new Employee();
        Programmer p = new Programmer();
        
        e.work();
        p.work();
    }
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;A polymorphic Employee&lt;/div&gt;


&lt;p&gt;The example shows that &lt;em&gt;Programmer&lt;/em&gt; is a specific kind of &lt;em&gt;Employee&lt;/em&gt;. There could be other kinds of Employees but this is enough to illustrate the point.&lt;/p&gt;

&lt;p&gt;If a programmer &lt;em&gt;is a kind of&lt;/em&gt; employee, then we expect the programmer to have the basic behaviour of an employee &amp;mdash; for example, you expect an employee to work, so you can expect a programmer to work as well. The work behaviour of all employees are not identical though. Some employees program (write codes), some of them do recruitment, some do the selling etc. This is the reason why you may need to provide specific behaviour to a specific object. A programmer is a specific kind of employee, therefore its &lt;em&gt;work&lt;/em&gt; behaviour or work details will be different from that of other employees.&lt;/p&gt;

&lt;p&gt;When you inherit a behaviour and then &lt;em&gt;reimplement&lt;/em&gt; that behaviour on a sub class, that makes the behaviour &lt;em&gt;polymorphic&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;POLYMORPHISM AND THE TYPE SYSTEM&lt;/h2&gt;

&lt;p&gt;If you can remember the idea and mechanics behind the Employee sample code above, you would already be okay and you can already accomplish a lot of things in Java. Lets stretch our understanding of polymorphism and the Java type system a little bit more. Consider the revised version of the Employee program.&lt;/p&gt;

&lt;pre&gt;
class Employee {
    
    void work() {
        System.out.println(&quot;I am working&quot;);
    }
}

class Programmer extends Employee {
    
    @Override
    void work() {
        System.out.println(&quot;I am programming&quot;);
    }
}

class TestEmployee {
    public static void main(String[] args) {
        Employee e = new Employee();
        Employee p = new Programmer();
        
        e.work();
        p.work();
    }
}

&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Overriding Example&lt;/div&gt;


&lt;p&gt;There are two new things in the sample code above. One is the &lt;em&gt;@Override&lt;/em&gt; annotation and the other is this code &lt;code class=&quot;codeblock&quot;&gt;Employee p = new Programmer()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;@Override&lt;/em&gt; is an annotation. They are tags that you insert in you code  so that the Java compiler or any other tool can use it for further processing. These tags can be processed at the source file level or it can be included in the resultant byte code.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;@Override&lt;/em&gt; is optional though, our previous code did accomplish the override without the annotation but don't be too quick to dismiss it. That is not just decoration. It gives some extra capabilities to the compiler.&lt;/p&gt;

&lt;p&gt;This annotation enables the compiler to check whether you are actually overriding the &lt;em&gt;work()&lt;/em&gt; method of the Employee class inside the Programmer class. If there was no &lt;em&gt;work()&lt;/em&gt; method defined in Employee, you will encounter a compilation error. Using the annotation helps you enforce your intent for a method to be truly polymorphic. If you doubt it, just play around with code and remove the &lt;em&gt;work()&lt;/em&gt; method on the Employee class, then recompile and see what happens.&lt;/p&gt;

&lt;p&gt;The other change is this is code &lt;code class=&quot;codeblock&quot;&gt;Employee p = new Programmer()&lt;/code&gt;. It might seem weird at first but it gives you hint of the Java Type System was designed.&lt;/p&gt;

&lt;p&gt;We declared the object reference &lt;em&gt;p&lt;/em&gt; to be of type &lt;em&gt;Employee&lt;/em&gt; but we did not create an instance of Employee, instead we assigned &lt;em&gt;p&lt;/em&gt; an instance of &lt;em&gt;Programmer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Java does not require us to fill up an Employee type with an actual Employee object. It only requires that we fill up the Employee type (variable &lt;em&gt;p&lt;/em&gt;) with an object that is &lt;em&gt;at least&lt;/em&gt; an Employee type. Of course class Programmer contains an employee type because it extends Employee, it is &lt;em&gt;a kind of&lt;/em&gt; Employee. You could add more types to the class Programmer via interface inheritance and, still our code will be perfectly legal.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;POLYMORPHISM AND ACCCESSIBILITY&lt;/h2&gt;

&lt;p&gt;When you override a method, make sure that you don't make the new method more RESTRICTIVE than the one in the super class.&lt;/p&gt;

&lt;p&gt;When you override a &lt;em&gt;public&lt;/em&gt; method, you have to make your new method public as well because nothing can be less restrictive than public.&lt;/p&gt;

&lt;p&gt;When you override a &lt;em&gt;protected&lt;/em&gt; method, you can only make it either a &lt;em&gt;public&lt;/em&gt; or a &lt;em&gt;protected&lt;/em&gt; method as well. Making the new method &lt;em&gt;protected&lt;/em&gt; does not make it less restrictive than the one in the superclass, it makes it equally restrictive, not less.&lt;/p&gt;

&lt;p&gt;When you override a &lt;em&gt;package access&lt;/em&gt; method, you have a choice to make the new method either &lt;em&gt;public, protected or default access&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Lastly when you override a &lt;em&gt;private&lt;/em&gt; method you have a choice to make it either public, protected or package access &amp;mdash; did that get pass by you? Didn't I say that private members cannot be inherited. If they can't be inherited, how can they be overriden? Gotcha. You got to pay attention to these things. You  CANNOT override private methods because you cannot inherit them to begin with.&lt;/p&gt;

&lt;p&gt;Now for some samples&lt;/p&gt;

&lt;pre&gt;
class Foo {
    public void do() {}
    protected void wah() {}
    void dee() {}
    private void dubidam() {}
}
class Goo extends Foo {   
    protected void do() {}
    public void wah() {}
    private void dee() {}
    void dubidam() {}
}
&lt;/pre&gt;


&lt;div id=&quot;cap&quot;&gt;Overriding and Accessibility&lt;/div&gt;


&lt;p&gt;In Goo, &lt;em&gt;protected void do()&lt;/em&gt; will fail because &lt;em&gt;do()&lt;/em&gt; in Foo is defined as public. Nothing can be less restrictive than public access, so Goo needs to declare &lt;em&gt;do()&lt;/em&gt; as public.&lt;/p&gt;

&lt;p&gt;The method &lt;em&gt;public void wah()&lt;/em&gt; in Goo is okay because public is less restrictive than &lt;em&gt;protected void wah()&lt;/em&gt; in Foo.&lt;/p&gt;

&lt;p&gt;The method &lt;em&gt;private void wah()&lt;/em&gt; in Goo will will fail because private is more restrictive than protected, &lt;em&gt;wah()&lt;/em&gt; is protected in the Super class Foo.&lt;/p&gt;

&lt;p&gt;Method &lt;em&gt;dee()&lt;/em&gt; in Goo will also fail because it private in Goo. Private is more restrictive than package access, which is how &lt;em&gt;dee()&lt;/em&gt; is declared in Super class Foo.&lt;/p&gt;

&lt;p&gt;The method &lt;em&gt;void dubidam()&lt;/em&gt; in Goo will not fail because it is not an override at all. A method declared as private cannot be inherited, and hence cannot be overridden. The &lt;em&gt;dubidam()&lt;/em&gt; method of Goo is simply a declaration of a new method unique to to class Goo, it is NOT a polymorphic method.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2&gt;POLYMORPHISM AND EXCEPTIONS&lt;/h2&gt;

&lt;p&gt;When you override methods that &lt;em&gt;throw&lt;/em&gt; exceptions you need to remember that &lt;em&gt;Exceptions&lt;/em&gt; are part of the method signature which means that your new method has to throw whatever the super class method was throwing.&lt;/p&gt;

&lt;pre&gt;
import java.io.IOException;
import java.sql.SQLException;

class Base {
    void doSomething() throws IOException, 
            ClassNotFoundException, 
            SQLException {
        
    }
}
class Child extends Base {
    @Override
    void doSomething() throws IOException, SQLException {
    }
}
&lt;/pre&gt;


&lt;p&gt;Your new method can throw less of those exceptions but it cannot throw more.&lt;/p&gt;

&lt;hr class=&quot;chapterbreak&quot;/&gt;




&lt;h1 class=&quot;chapter&quot;&gt;BIBLIOGRAPHY&lt;/h1&gt;


&lt;p&gt;[1] James Gosling, &lt;em&gt;The Java Programming Language&lt;/em&gt;. 3rd ed, 1999&lt;/p&gt;

&lt;p&gt;[2] James Gosling, &lt;em&gt;The Java Language Specification&lt;/em&gt;. 3rd ed, 1999&lt;/p&gt;

&lt;p&gt;[3] Maurice Naftalin &amp;amp; Philip Wadler. &lt;em&gt;Java Generics Collection&lt;/em&gt;. O'Reilly, 2006&lt;/p&gt;

&lt;p&gt;[4] Cay S. Hoffman, Gary Cornell, &lt;em&gt;Core Java 2 Volume I&lt;/em&gt;, Prentice Hall PTR, 2004&lt;/p&gt;

&lt;p&gt;[5] Cay S. Hoffman, Gary Cornell, &lt;em&gt;Core Java 2 Volume II&lt;/em&gt;, Prentice Hall PTR, 2004&lt;/p&gt;

&lt;p&gt;[6] Timothy Fisher, &lt;em&gt;The Java Phrasebook: Essential Code and Commands&lt;/em&gt;. Sams, 2006&lt;/p&gt;

&lt;p&gt;[7] Robert Simmons Jr., &lt;em&gt;Hard Core Java&lt;/em&gt;. O'Reilly, 2004&lt;/p&gt;

&lt;p&gt;[8] Bjarne Stroustrup, &lt;em&gt;Why C++ is not just an Object Oriented Programming Language&lt;/em&gt;. AT&amp;amp;T  Bell Laboratories&lt;/p&gt;

&lt;p&gt;[9] Boone and Stanek, &lt;em&gt;Java 2 Exam Guide&lt;/em&gt;. McGraw Hill, 2000&lt;/p&gt;

&lt;p&gt;[10] Kathy Sierra &amp;amp; Bert Bates, &lt;em&gt;SCJP Sun Certified Programmer for Java 6 Study Guide&lt;/em&gt;. McGraw Hill, 2008&lt;/p&gt;

&lt;p&gt;[11] Jonathan Krudsen &amp;amp; Patrick Niemeyer, &lt;em&gt;Learning Java, 3rd Edition&lt;/em&gt;. O'Reilly, 2005&lt;/p&gt;

&lt;p&gt;[12] Ivar Jacobson, Rumbaugh, &lt;em&gt;Object Oriented Analysis and Design, 3rd ed.&lt;/em&gt;, 1965&lt;/p&gt;

&lt;p&gt;[13] Robert Sebesta, &lt;em&gt;The Concept of Programming Languages, 10th ed.&lt;/em&gt;, Addison Wesley, 2012&lt;/p&gt;
</content>
 </entry>
 
 
</feed>